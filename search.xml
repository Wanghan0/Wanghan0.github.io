<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[理解javascript作用域]]></title>
      <url>%2F2017%2F05%2F02%2Fjs-scopeChain%2F</url>
      <content type="text"><![CDATA[任何程序设计语言都有作用域的概念，简单的说，作用域就是变量或函数的有权访问其他数据的范围。在JavaScript中，变量的作用域有全局作用域和局部作用域两种，并且局部作用域是按照函数划分的，而不是块级作用域，下面我们就来详细区分一下这些作用域。 函数作用域和块级作用域 在Java、C或C++中，花括号{}内封闭的代码块有自己的作用域，在{}外部无法访问{}内部的变量，这个作用域就称为块级作用域。 在javascript中不存在块级作用域，而是把每个函数作为一个作用域，在函数外部无法访问函数内部的变量。 为了解决块级作用域，ES6引入了新的关键字let，用let替代var可以申明一个块级作用域的变量。 举个栗子： function test() { if (true){ var color=&quot;blue&quot;; } alert(color); } 在Java、C或C++中，if语句内部是一个块作用域，color变量在if语句中声明，并在if语句执行完毕后被销毁，即就是说if语句外部不可访问内部的变量，因此本例alert(color)将出现报错undefined。 在javascript中，test()函数内部是一个函数作用域，由于没有块作用域，if语句中的变量声明也属于当前的函数作用域，alert命令在该作用域内部，可以访问color变量，因此本例alert(color)将输出“blue”。 再举个栗子： function test() { for(var i=0; i&lt;10;i++){ doSomething(i); } alert(i); } 在Java、C或C++中，for语句内部是一个块作用域，其初始化变量的表达式所定义的变量（本例中是变量i），只会存在于循环的环境之中（即该块作用域），因此本例alert（i）将出现报错undefined。 在javascript中，test()函数内部是一个函数作用域，由于没有块作用域，由for语句创建的变量i即使在for循环执行结束后也依旧会存在于循环外部的函数作用域中，因此本例alert（i）将输出10。 如果本例中用let替代var定义变量i，那么alert（i）也会报错，因为用let替代var可以申明一个块级作用域的变量。 全局作用域在代码中任何地方都能访问到的对象拥有全局作用域，一般来说以下3种变量对象拥有全局作用域： 最外层函数和在最外层函数外面定义的变量。 所有末定义直接赋值的变量将被自动添加到全局作用域（但是严格模式下，初始化未经声明的变量会导致错误）。 所有window对象的内置属性，例如window.name、window.location、window.top等等都是全局变量，并且所有属于全局作用域的变量都是window对象的属性。 举个栗子： var a=1; function test() { var b =2; c=3; alert(&quot;执行了test1函数&quot;); } alert(a); //输出1，因为变量a是最外层函数外面定义的变量 alert(b); //报错undefined test(); //弹出“执行了test1函数”，因为test()是最外层函数 alert(c); //输出3，因为末定义直接赋值的变量将被自动添加到全局作用域 alert(window.location); //弹出了文档当前地址和相关信息，因为window的内置属性是全局变量 alert(window.a); //输出1，因为全局作用域变量a也是window对象的属性 上例需要注意一点，如果在调用test()之前alert(c)会报错，因为你如果没有调用过这个函数，浏览器根本不会读取到函数里面的这个变量c。 局部作用域只在函数内部才能访问到的对象拥有局部作用域。举个栗子： function test() { var b =2; alert(b); } alert(b); //报错undefined，因为这个alert命令位于函数外部，访问不到函数内部的变量b test(); //2，因为调用这个函数时，执行了函数内部的alert命令，可以访问到变量b 作用域链前面的例子都很好理解，因为我定义的变量都是不同的，互不干扰，但是如果局部变量跟全局变量重名了就会比较难以判断。举个栗子： var a =1; function test(){ alert(a); var a = 2; alert(a); } test(); //undefined,2 估计很多人都会以为在调用test()函数时会弹出1，2，但事实上弹出了undefined,2，要理解其中的缘由，那必须理解作用域链。 概念：作用域链的作用就是保证对作用域内有权访问的变量和函数的有序访问（这句话贼绕）。通俗地说，作用域链可以被看作一种有秩序的路径,在变量解析过程中首先查找当前局部的作用域，然后查找上层作用域，内到外地查找，直到到找到最近定义的的该变量。 那么现在再去理解一下上面的例子，第一次alert(a)的时候，先在当前作用域中也就是函数test()内部查找到变量a已经被定义，但是此时并没有赋值，所以输出undefined；第二次alert(a)的时候，当前局部作用域中查找到已经赋值的变量a,所以输出2。 再举个栗子： var a =1; function test(){ var b = 2; alert(a); alert(b); alert(c); function test2() { var c = 3; } } test(); //1,2,undefined alert(a)：当前局部作用域test()内部查找变量a没有找到，上层全局作用域查找到a =1，输出1。 alert(b)：当前局部作用域test()内部查找变量b得到b=2，输出2。 alert(c)：当前局部作用域test()内部查找变量c没有找到，上层全局作用域也没有找到，输出undefined。 另外，从作用域链的结构可以看出，被访问的对象所在的位置越深，读写速度就会越慢。因为全局变量总是存在于作用域链的最末端，因此查找全局变量是最慢的。所以，在编写代码的时候应尽量少使用全局变量，多使用局部变量。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[浮动与清除浮动]]></title>
      <url>%2F2017%2F04%2F29%2Fcss-float%2F</url>
      <content type="text"><![CDATA[浮动浮动的概念浮动元素会脱离文档流并向左/向右浮动，直到碰到父元素或者另一个浮动元素。 float：left | right | none | inherit 举个栗子: 当框 1 向右浮动时，它脱离文档流并且向右移动，直到它的右边缘碰到包含框的右边缘。 当框 1 向左浮动时，它脱离文档流并且向左移动，直到它的左边缘碰到包含框的左边缘。因为它不再处于文档流中，所以它不占据空间，框2填补了它的位置且被覆盖，使框 2 从视图中消失。 如果把所有三个框都向左浮动，那么框 1 向左浮动直到碰到包含框，另外两个框向左浮动直到碰到前一个浮动框。 浮动的特性 脱离文档：元素设置为浮动后脱离文档流，并不占据空间，而此浮动元素在文档流空出的位置，由后续的非浮动元素填充，块级元素直接填充上去，内联元素则有空隙就插入。 浮动可以内联排列：浮动会向左/向右浮动，直到碰到另一个浮动元素为止，这是浮动可以内联排列的特征。也就是说，浮动可以设置宽高，并且能够一行多个，类似于inline-block属性的效果。 父元素高度坍塌：浮动元素脱离了文档流，并不占据文档流的位置，自然父元素也就不能被撑开，所以没了高度。 清除浮动清除浮动的概念在非IE浏览器（如Firefox）下，当容器的高度为auto，且容器的内容中有浮动（float为left或right）的元素，在这种情况下，容器的高度不能自动伸长以适应内容的高度，使得内容溢出到容器外面而影响（甚至破坏）布局的现象。这个现象叫浮动溢出，为了防止这个现象的出现而进行的CSS处理，就叫CSS清除浮动。举个栗子：html： &lt;div class=&quot;out&quot;&gt; &lt;div class=&quot;box&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;3&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;4&lt;/div&gt; &lt;/div&gt; css： .out{ width: 300px; border: 2px solid #55a532; } .box{ background-color: #f7c942; height: 50px; width: 50px; } 上面是未设置浮动时的效果，下面我们给容器里面的子元素设置向左浮动： .box{ background-color: #f7c942; height: 50px; width: 50px; float: left; } 我们可以看到，子元素设置浮动后父元素只剩下了重合后的边框，这是因为元素脱离了文档流，不能撑开父元素，所以父元素的高度坍塌了，而子元素也溢出到容器外面，这就是浮动溢出现象。要消除这个现象就得清除浮动。 清除浮动的方法方法一：添加带clear属性的空元素clear 属性规定元素的哪一侧不允许其他浮动元素。 clear ：left | right | both | none | inherit 我们给浮动元素后面添加一个空元素 &lt;div class=&quot;out&quot;&gt; &lt;div class=&quot;box&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;3&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;4&lt;/div&gt; &lt;div class=&quot;none&quot;&gt;&lt;/div&gt; &lt;/div&gt; 给空元素设置clear属性 .none{ clear: both; } 原理是设置clear后，父容器必须考虑非浮动子元素的位置，而后者肯定出现在浮动元素下方，所以显示出来，父容器就把所有子元素都包括进去了 另外，如果浮动元素后面存在着不浮动的块元素，那么直接给后者添加clear: both属性即可，不必添加空元素多此一举。 方法二：after伪元素after伪元素可以在父容器的尾部自动创建一个子元素，也就是说我们不必修改html，可以直接通过css来添加新元素，达到跟上一种方法同样的效果。 .out:after { content: &quot;&quot;; display: block; height: 0; clear: both; } .out{ zoom: 1; } content属性，表示伪元素的内容,设置:before和:after时必须设置其content属性，否则伪元素就不起作用，本例content: “”表示给父元素结尾放了一个空白字符。 after添加的内容默认是inline元素，但是行内元素会找空隙插入浮动元素，依然撑不起父容器高度，所以我们需要把插入的元素设置成块元素block。 height: 0是让这个这个空白字符不显示出来。 由于IE6不支持after，我们添加一条IE6的独有命令”zoom:1”就行了，这条命令的作用是触发父元素的”hasLayout”属性（即令hasLayout的值为true），让父元素拥有自己的布局，IE6会读取这条命令，其他浏览器则会直接忽略它。 （haslayout为true时，它就不得不去渲染它自己，因此元素不得不扩展去包含它的流出的内容，例如浮动，而zoom:1是最常用，最安全，成本最少的触发hasLayout的方式。） 方法三：父元素设置overflow: auto/hidden给浮动元素的父元素添加overflow: auto或者overflow: hidden属性之后会自动计算超出的大小，所以父容器会自动撑开自己把所有的子元素放进去，浮动元素也回到了容器层，达到了清理浮动的效果。但是如果子元素的大小超过父容器的大小，就会出现显示问题,不推荐使用。 .out{ overflow: auto; zoom: 1; /*处理ie6兼容问题*/ } 方法四：父元素设置浮动给浮动元素的容器也添加上浮动属性即可清除内部浮动，但是这样会使其整体浮动，影响布局，也容易出现新的浮动问题，不推荐使用。 .out{ float: left; } 方法五：父元素设置display:table将父容器变成表格可以清除浮动，但是非表格内容用table来装，不符合标签语义化要求，还可能会出现未知问题，故不推荐使用。 .out{ display: table; } 小结据说浮动诞生的时候主要是用来实现文字围绕图片的效果，但是后来越来越多的人用它来布局，虽说存在的即合理的，用浮动布局确实有它的道理和好处，但是对我来说，我还是不太喜欢用浮动来布局，绝对定位也是一样，他们总给我一种不安全感，让我觉得我的页面不是一个整体，随时都有可能崩坏。总之打好基础才是做出一个稳定页面的前提，道阻且长。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[flex布局语法篇]]></title>
      <url>%2F2017%2F04%2F26%2Fflex%2F</url>
      <content type="text"><![CDATA[之前写过一篇关于实现元素居中的博文，我们发现每种布局要求都可以运用flex布局实现。其实令元素居中只是flex强大的其中一个体现，可以说不管是什么布局，flex往往都可以几行命令搞定。今天我就来总结一下关于flex语法方面的内容。 基本概念Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。flex是一个布局模块，而不是一个简单的属性，它可以实现各种各样的布局，可以在任何流动的方向上(包括上下左右)都能进行良好的布局，也以弹性的在任意的容器中伸缩大小，可以方便让元素对齐容器的左、右、中间等等。任何元素都可以指定flex布局，但是要注意设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。 相关术语 弹性容器(Flex container)：包含着弹性项目的父元素。通过设置 display 属性的值为 flex 或 inline-flex 来定义弹性容器。 弹性项目(Flex item)：弹性容器的每个子元素都称为弹性项目。弹性容器直接包含的文本将被包覆成匿名弹性单元。 轴(Axis)：每个弹性框布局包含两个轴。弹性项目沿其依次排列的那根轴称为主轴(main axis)。垂直于主轴的那根轴称为侧轴(cross axis)。 方向(Direction)：弹性容器的主轴起点(main start)/主轴终点(main end)和侧轴起点(cross start)/侧轴终点(cross end)描述了弹性项目排布的起点与终点。 容器的属性flex-direction flex-direction定义了伸缩容器的主轴，决定了伸缩项目放置在伸缩容器的方向 。 flex-direction: row | row-reverse | column | column-reverse row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 flex-wrapflex-wrap定义了伸缩容器的侧轴，侧轴的方向决定了新行堆放的方向（即是否换行）。 flex-wrap: nowrap | wrap | wrap-reverse nowrap(默认值)：不换行。 wrap：换行，第一行在上方。 wrap-reverse：换行，第一行在下方。 flex-flowflex-flow是flex-direction和flex-wrap属性的缩写；同时定义了伸缩容器的主轴和侧轴，其默认值为row nowrap。 flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt; 举个栗子： .container-1{ flex-flow: row-reverse wrap-reverse; } .container-2{ flex-flow: column wrap; } justify-contentjustify-content定义了项目在主轴上的对齐方式。 justify-content: flex-start | flex-end | center | space-between | space-around flex-start(默认值)：向起始位置靠齐。 flex-end：向结束位置靠齐。 center：居中。 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 align-itemsalign-items定义项目在侧轴上如何对齐， align-items: flex-start | flex-end | center | baseline | stretch stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 flex-start：侧轴的起点对齐。 flex-end：侧轴的终点对齐。 center：侧轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。下面例图基于主轴方向为flex-direction：row，水平对齐方式为justify-content: space-between，依次改变侧轴对齐方式 align-items： align-contentalign-content定义了多根轴线（多行排列）的对齐方式。如果项目只有一根轴线（单行），该属性不起作用，即必须设置换行flex-wrap: wrap。这个属性与上面的align-items相似，把一根轴线（行）看作是一个项目就好理解了。 align-content: flex-start | flex-end | center | space-between | space-around | stretch stretch（默认值）：轴线占满整个侧轴。 flex-start：与侧轴的起点对齐。 flex-end：与侧轴的终点对齐。 center：与侧轴的中点对齐。 space-between：与侧轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 项目的属性orderorder属性定义项目的排列顺序。数值越小，排列越靠前，默认值为0，伸缩项目是按照文档流出现先后顺序排列。可以取负值。 order: &lt;integer&gt; 举个栗子：下面让第一个元素排在最后，最后一个元素排在第一个 .container{ display: flex; } .container .item-6{ order: -1; } .container .item-1{ order: 1; } flex-grow flex-grow定义项目的扩展比例，项目根据容器的剩余空间按比例扩展。默认值为0，即如果存在剩余空间，也不扩展。如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。负值对该属性无效。 flex-grow: &lt;number&gt; 举个栗子： .container-1,.container-2,.container-3{ margin-bottom: 30px; display: flex; justify-content: space-between; } .container-2 .item-1,.container-2 .item-2,.container-2 .item-3{ flex-grow: 1; } .container-3 .item-2{ flex-grow: 2; } .container-3 .item-1,.container-3 .item-3{ flex-grow: 1; } flex-shrinkflex-shrink定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。负值对该属性无效。 flex-shrink: &lt;number&gt; 举个栗子： .container-1,.container-2,.container-3{ display: flex; margin-bottom: 30px; justify-content: space-between; } .container-2 .item-1,.container-2 .item-2,.container-2 .item-3{ flex-shrink: 0; } .container-3 .item-1{ flex-shrink: 0; } .container-3 .item-2{ flex-shrink: 1; } .container-3 .item-3{ flex-shrink: 2; } align-selfalign-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 align-self: auto | flex-start | flex-end | center | baseline | stretc 举个栗子： .container{ display: flex; align-items: flex-start; } .container .item-4{ align-self: flex-end; } flex-basisflex-basis定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。它可以设为跟width或height属性一样的值，则项目将占据固定空间。 flex-basis: &lt;length&gt; | auto flexflex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。 flex: none | [ &lt;flex-grow&gt; &lt;flex-shrink&gt; || &lt;flex-basis&gt; ] 小结今天的flex语法就说这么多吧，写这篇文章参考了阮一峰老师的flex语法教程，他写的真的特别好，清晰有条理，也通俗易懂，我参照他的教程加入自己的理解，写出这篇博文，文章里所有的例子图片都是我自己敲着代码做出来的，也算是收获巨大，后面有时间的话还会再写一篇关于flex实例的文章，学以致用。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[详解绝对定位和相对定位]]></title>
      <url>%2F2017%2F04%2F25%2Fcss-position%2F</url>
      <content type="text"><![CDATA[上一篇博文中对元素的居中方式进行了总结，其中很多方法中都用到了相对定位和绝对定位，关于这两种定位方式确实是CSS中的一大难点，如果不能深入了解这两种定位方式，进行页面排版时就容易出现混乱，所以今天我对position的所有属性取值进行一个总结，重点剖析绝对定位和相对定位之间的联系和区别。 position的不同取值 不管是哪种定位，都必须有一个参照物，理清参照物我们就对这些定位方式了解了一半。 static，默认值。位置设置为static的元素，它始终会处于页面流给予的位置（static 元素会忽略任何 top、bottom、left、right和z-index 声明）。 inherit，规定应该从父元素继承 position 属性的值。但是任何的版本的 Internet Explorer （包括 IE8）都不支持属性值 “inherit”。 fixed，生成绝对定位的元素，可定位于相对于浏览器窗口的指定坐标。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。不论窗口滚动与否，元素都会留在那个位置。 absolute，生成绝对定位的元素，相对于距该元素最近的已定位（position不为static）的祖先元素进行定位。此元素的位置可通过 “left”、”top”、”right” 以及 “bottom” 属性来规定。 relative，生成相对定位的元素，相对于该元素在文档中的初始位置进行定位。通过 “left”、”top”、”right” 以及 “bottom” 属性来设置此元素相对于自身位置的偏移。 相对定位relative 相对定位的参照物是它本身 每一个元素都可以看作一个盒子，文档流就是由这些盒子堆砌而成，而每个盒子都在这个文档流中占据了一个位置，如果我们把这个盒子设置成相对定位，那么就可以拿起这个盒子相对于它原来所占据的位置向别的地方移动，如设置left:50px就是相对于盒子原来位置向左移动了50个像素，我们用具体的例子来说明。下面是一个所有元素都没有设置过任何定位方式的原始页面布局。 我们把box-2设置成相对定位并向左移动60像素，向下移动120像素。 .box-2{ background-color: #00A5FF; position: relative; left: 110px; top:60px; } 得到下面的效果 从上图我们可以发现box-2相对于它原来的位置向下且向右移动了，并且原来的位置留下了一片空白，但是其他的元素并没有占据它，说明元素设置相对定位后，可以相对于其在普通流中的位置偏移，原本所占的空间仍保留。 同时我们从图上可以看出，box-2移动之后覆盖了其他的元素，这说明当元素被设置相对定位后，将激活z-index属性，其层叠级别高于原本的文档流。此时如果给box-5也设置 position: relative，那么box-5又会覆盖box-2。绝对定位absolute 绝对定位的参照物是相对于该元素最近的已定位的祖先元素，如果没有一个祖先元素设置定位，那么参照物是body。 绝对定位与相对定位的一大不同之处就是，当我们把一个元素设置成相对定位，那么这个元素将会脱离文档流，漂浮在文档流上方，并且后面的元素将会填充它原来的位置。绝对定位元素根据它的参照物移动自己的位置，而参照物则需要根据它祖先元素的定位设置来确定。我们就用实例说明绝对定位的特点和需要注意的地方。下面是一个所有元素都没有设置过任何定位方式的原始页面布局。 祖先元素都没有设置定位，元素相对于body转移位置。给box-2设置成position: absolute; .box-2{ background-color: #00A5FF; position: absolute; } 得到下面的效果 我们可以看到最后一个box存在的位置空了出来，这是因为box-2脱离文档流漂浮到文档上方，并且后面的元素填补了上去，说明元素设置绝对定位后脱离文档流，后面的元素将填补它的位置。 接着你可能就会发现box-3失踪了，其实它没有失踪，它是在box-2下面，就像相对定位一样，当元素被设置绝对定位后，将激活z-index属性，其层叠级别高于原本的文档流。 你可能会问了，不是说祖先元素都没有定位时，元素会相对于body来改变自己的位置吗，为什么它还是飘在原来的位置，而没有飘到body顶头呢，那么请看，我把left和top属性加上会出现什么样的结果。 .box-2{ background-color: #00A5FF; position: absolute; left: 0; top:0; } 得到下面的效果 现在可以看到它与body顶头了，因为光设置一个元素的相对定位它只会漂浮到原来位置的上空，并不会漂浮到参照物的文档流最前方，而只有设置了left、top、right、bottom这些参数的时候才能激活它相对于参照物移动的效果。 祖先元素grandpa设置定位，元素相对于grandpa转移位置。 .grandpa{ background-color: #55a532; height: 500px; width: 600px; margin: 40px; position: relative; } .box-2{ background-color: #00A5FF; position: absolute; left: 20px; top:20px; } 得到下面的效果 祖先元素father设置定位，元素相对于father转移位置。 .father{ background-color: #55a532; height: 400px; width: 500px; margin: 50px; position: relative; } .box-2{ background-color: #00A5FF; position: absolute; left: 20px; top:20px; } 得到下面的效果 父元素son以及祖先元素father、grandpa都设置定位，元素相对于son转移位置。 .grandpa,.father,.son{ position: relative; } .box-2{ background-color: #00A5FF; position: absolute; left: 20px; top:20px; } 得到下面的效果 当祖先元素不止一个设置了定位的时候，选择最近的一个作为参照物。 小结现在你应该就能明白为什么上一篇博文中那么多居中方式都要设置其父元素的position为relative了吧，其实虽然absolute要求的是祖先元素的定位方式是除static都可以，但是最好还是设置成相对定位，因为你只设置relative而不设置left、top等参数的话对元素自身和其他元素是没有影响的，但如果你设置成fixed，元素就有可能受到浏览器窗口的影响（如果有特殊需要当然可以使用），而你设置成inherit也没有什么意义，况且浏览器对它的支持性也不是很好，显然用来限制absolute的话用relative是最合适的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS各种居中实现方式]]></title>
      <url>%2F2017%2F04%2F24%2Fcss-center%2F</url>
      <content type="text"><![CDATA[很多人刚学CSS的时候可能会觉得它很简单，心想不就是一个“背”字吗，把这些样式全记下不就行了吗？其实你一段时间之后就会明白，背是远远不够的，你需要弄清每一个属性的不同值分别得到什么效果，几个属性的组合又会带来什么结果，只有由内而外地理解这些属性，才能找到最便捷的方法达到你想要的效果，理解不是背出来的，是无数次的实践和踩坑得到的。 CSS居中是每次布局都需要面对的问题，我也是踩了无数次的坑才得出一点感悟和经验，今天我就对它做个总结，我相信一个全面的总结会对以后的学习和实践带来很大的帮助。 内联元素 内联元素的特点 和其他元素都在一行上 设置高度height 无效，可以通过line-height来设置 设置margin和padding只有左右有效，上下无效 宽度就是它的文字或图片的宽度，不可改变 内联元素只能容纳文本或者其他内联元素 以下实例都是基于下面的html代码： &lt;div class=&quot;out&quot;&gt; &lt;span class=&quot;in&quot;&gt; 居中元素 &lt;/span&gt; &lt;/div&gt; 水平居中 父元素样式设置为text-align:center，里面包含的行内元素居中,如果父元素内部还存在包含文字且不定宽的块元素，那么这个块元素也会居中。 .out{ text-align: center; } 父元素样式设置为display:flex; justify-content:center，里面包含的行内元素居中。 .out{ display:flex; justify-content:center } 垂直居中 单行文本：可将其父元素的高度和行高设置为相等的值 height = line-height .out{ height: 100px; line-height: 100px; } 多行文本：用一个span标签将所有的文字封装起来，再用一个容器包裹span，设置属性display: table-cell;vertical-align: middle。这种方法同样适用于使图片居中。 .out{ display: table-cell; vertical-align: middle; } 父元素样式设置为display: flex;align-items: center，里面包含的行内元素居中。 .out{ height: 100px; line-height: 100px; } 父元素样式设置为display:flex; align-items: center，里面包含的行内元素居中。 .out{ display:flex; align-items: center; } 块级元素 块级元素的特点 总是在新行上开始，占据一整行 高度，行高以及外边距和内边距都可控制 宽度缺省是它的容器的100%，除非设定一个宽度 它可以容纳内联元素和其他块元素 以下实例都基于下面的html代码： &lt;div class=&quot;out&quot;&gt; &lt;div class=&quot;in&quot;&gt; 居中元素 &lt;/div&gt; &lt;/div&gt; 水平居中定宽块级元素水平居中 父元素样式设置为display:flex; justify-content:center，则里面包含的块元素居中 .out{ display:flex; justify-content:center; } 该元素样式设置为 margin：0 auto； .in{ width: 100px; margin: 0 auto; } 该元素样式设置为 position: relative;left: 50%；margin-left: -0.5*width（负的该元素宽度的一半） .in{ width: 100px; position: relative; left: 50%; margin-left: -50px; } 上述方法把relative改为absolute也同样适用，根据实际情况选择适合自己的方法。 .in{ width: 100px; position: absolute; left: 50%; margin-left: -50px; } 不定宽块级元素水平居中 对于包含文字的块元素可将其父元素设置为text-align:center .out{ text-align:center; } 若不包含文字，可把该块级元素变成行内元素，即设置display:inine，再给其父元素设置text-align:center .out{ text-align:center; } .in{ display:inine; } 父元素样式设置为display:flex; justify-content:center，则里面包含的块元素居中 .out{ display:flex; justify-content:center; } 该元素样式设置为 position: absolute;left: 50%;transform: translate(-50%,0) .in{ position: absolute; left: 50%; transform: translate(-50%,0); } 垂直居中定高块级元素垂直居中 父元素样式设置为display:flex; align-items: center，则里面包含的块元素居中 .out{ display:flex; align-items: center; } 该元素样式设置为 position: relative;top: 50%；margin-top: -0.5*height（负的该元素高度的一半） .in{ height:100px; position: relative; top: 50%; margin-top:-50px; } 该元素的父元素的position值设置为relative，将该元素样式设置为position: absolute;top:50%;margin-top: -0.5*height .out{ position: relative; } .in{ height:100px; position: absolute; top:50%; margin-top: -50px } 该元素的父元素的position值设置为relative，将该元素样式设置为position: absolute;top:0;bottom: 0;left: 0;right: 0;margin: auto; .out{ position: relative; } .in{ height:100px; position: absolute; top:0; bottom: 0; left: 0; right: 0; margin: auto; } 不定高块级元素垂直居中 父元素样式设置为display:flex; align-items: center，则里面包含的块元素居中 .out{ display:flex; align-items: center; } 该元素样式设置为 position: relative;top: 50%;transform: translate(0,-50%) .in{ position: relative; top: 50%; transform: translate(0,-50%); } 该元素的父元素的position值设置为relative，将该元素样式设置为position: absolute;top:50%;translate(0,-50%) .out{ position: relative; } .in{ position: absolute; top: 50%; transform: translate(0,-50%); } 小结 总结到这里就会发现令元素居中的办法千奇百怪，其中无论水平还是垂直，无论有没有指定宽高，总能奏效的办法就是display:flex办法，这也是flex布局的优势之一，有时候使用flex布局甚至比bootstrap这种框架更加顺手，有机会我也会对flex做个总结。 另外在上面的很多居中的办法中都用到了position: absolute，但是其实不建议经常使用绝对定位进行布局，因为它脱离了文档流，有时会造成元素的塌陷。因为关于position的不同取值带来的效果经常使人困扰，后面我也会对它进行总结。 还有，居中的办法有这么多，但并不代表你需要懂得每一种，甚至去学会一些奇怪或者复杂的居中方式，而是在布局的过程中选择最适合、最简单、你用的最顺手的方法实现你想要的效果，俗话说黑猫白猫，能抓住耗子的就是好猫，居中方式也是一样的道理。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[谈谈我对盒模型的理解]]></title>
      <url>%2F2017%2F03%2F31%2Fcss-box%2F</url>
      <content type="text"><![CDATA[盒子是无处不在的。html任何一个元素都可以看作一个盒子，这个盒子不可见，但是它存在于页面的每个角落，也正是由于它不可见、不直观，很多人在初学CSS的时候不能透彻得理解盒模型的概念，导致在页面布局中出现各种各样的问题。 盒子模型简介 上面是一个盒子模型图，一个盒子包括了content（实际内容）、border（边框）、padding（内边距）和margin（外边距）。 content（实际内容）盒子的内容，显示文本和图像。我们给元素设置的width和height其实是content的宽高， 如果指定高度大于显示内容所需高度，多余的高度会产生类似内边距一样的效果；如果指定高度小于显示内容所需高度，会出现滚动条。如果元素内容的高度大于元素框的高度，浏览器的具体行为取决于overflow属性。 border（边框）元素的边框是围绕元素内容的内边距的一条或多条线。边框由粗细、样式和颜色三部分组成。 padding（内边距）清除内容周围的区域，内边距是透明的，取值不能为负，受盒子的Background属性影响，padding是有背景的。 margin（外边距）在元素外创建额外的空白，空白通常指不能放其他元素的区域，而且在这个区域中可以看到父元素的背景（padding所带的是本身的背景而非父元素）。margin经常取负值实现定位的作用。外边距有一个合并问题，经常使人们混淆，简单来说，外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。 两种盒子模型其实盒模型有两种，分别是ie盒子模型（IE6以下版本浏览器)和标准w3c盒子模型，区别在于前者content的宽度和高度包括了border和padding。margin（外边界）虽不可见，但是它确实在文档中占据了空间，我们要区分两个概念即：盒子所占空间（计入margin ）和盒子实际的大小（不计入margin） 。 实例区分两种盒模型下面举个例子来区分两种盒模型：一个盒子的 margin 为 20px，border 为 2px，padding 为 10px，content 的宽为 200px、高为 50px。 ie盒子模型盒子所占空间：width=20ｘ2+200=240 height=20ｘ2+50=90 盒子实际大小：width=200 height=50 标准w3c盒子模型盒子所占空间：width=20ｘ2+2ｘ2+10ｘ2+200=264 height=20ｘ2+２ｘ2+10ｘ2 +50=114 盒子实际大小：width=200 +2ｘ2+10ｘ2 =224 height=50+2ｘ2+10ｘ2=74 解释到这里，有的人可能会想起CSS3里面有个叫做box-sizing的属性，咦？两个盒模型不就是它不同取值下的效果吗？那我恭喜你，你说对了～ box-sizing和两种盒模型不得不说的事box-sizing有三个取值： 1、content-box:使元素遵循标准 w3c 盒子模型（默认值）。 2、border-box:使元素遵循ie 盒子模型。 3、 inherit： 规定应从父元素继承 box-sizing 属性的值。 那么我可以用box-sizing的不同取值让大家直观地理解两个盒子的区别，也顺带理解这个属性，下面是需要用到的html代码，方便大家看得清楚，我给盒子外面添加一个宽高各500px的灰色背景。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;盒模型&lt;/title&gt; &lt;link href=&quot;盒模型.css&quot; type=&quot;text/css&quot; rel=&quot;stylesheet&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;bg&quot;&gt; &lt;div class=&quot;box&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; box-sizing：content-box.box{ background-color: #91D4DA; width: 300px; height: 300px; padding: 20px; border: 10px solid #5B5B5B; box-sizing: content-box; /*默认值，可以不写*/ } 下面改变padding和border的值 .box{ background-color: #91D4DA; width: 300px; height: 300px; padding: 50px; border: 20px solid #5B5B5B; box-sizing: content-box; /*默认值，可以不写*/ } 大家可以发现，元素盒子的实际宽度是随padding和border改变的。 box-sizing：border-box： .box{ background-color: #91D4DA; width: 300px; height: 300px; padding: 20px; border: 10px solid #5B5B5B; box-sizing: border-box; } 下面改变padding和border的值 .box{ background-color: #91D4DA; width: 300px; height: 300px; padding: 50px; border: 20px solid #5B5B5B; box-sizing: border-box; } 发现区别了吧，当你遵循ie盒子模型时，不管你如何设置padding和border（小于width/2），它只在盒子里面伸缩，不影响整体的宽高，这个border-box是不是在某些时候非常好用？但也不能盲目地用，因为它会影响content，如果padding和border太大，会把内容挤掉的。 现在还在用IE6以下的浏览器的用户已经很少了，所以目前浏览器大部分元素都是基于W3C标准盒子模型 上。所以我们平常说的盒子模型一般就是标准 w3c 盒子模型 （但对于input、button元素默认border-box ，还是基于传统的ie 盒子模型 ）。一定有人会问，那我们怎样让我们的元素都遵循W3C标准盒子模型呢？哈哈，看看你html的文件头部是不是有一个&lt;!DOCTYPE html&gt;，有这个，就说明你已经遵循W3C标准盒子模型了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一个简易弹幕]]></title>
      <url>%2F2017%2F02%2F11%2Fdanmu%2F</url>
      <content type="text"><![CDATA[这是一个用jquery写的弹幕，下面是一点心得。编写jquery的要点在于以下几个方面：1.获取随机高度和随机颜色2.绑定点击和回车事件3.获取输入内容并以动画形式添加到窗口下面贴出完整代码，一些细节都会提到 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;弹幕&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; body{ background-color: gainsboro; } .main{ margin:auto; background-color:rgba(71,71,71,0.95); height: 500px; width: 60%; } .screen{ background-color: antiquewhite; margin: 0; padding: 0; width: 100%; height: 90%; position: relative; overflow: hidden; /*overflow: hidden对screen外的部分进行裁剪，弹幕内容只出现在screen中*/ } .input{ margin-left: 17%; margin-top: 10px; padding-left: 2%; width: 50%; height: 30px; border-radius: 10px 0 0 10px; border: none; } .button{ position: relative; top:-32px; padding: 0; margin-left: 69%; height: 32px; width: 10%; border-radius: 0 10px 10px 0; background-color: rgba(80,188,50,0.95); border: none; color: white; } .button:hover{ background-color: rgba(66,156,42,0.95); cursor: pointer; } #spa{ position: absolute; /*在JS中定义top,right要建立在 position: absolute基础上*/ width: 200px; /*设置弹幕的宽度*/ right: -200px; /*弹幕从screen边界右边200px处开始，与宽度相等，当大于宽度时会延迟到来时间，小于时会从screen内部开始*/ } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;screen&quot;&gt; &lt;/div&gt; &lt;div class=&quot;foot&quot;&gt; &lt;input id=&quot;in&quot; class=&quot;input&quot; type=&quot;text&quot; placeholder=&quot;说点什么...&quot;&gt; &lt;button id=&quot;btn&quot; class=&quot;button&quot; type=&quot;button&quot;&gt;发送&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;script language=&quot;javascript&quot; src=&quot;http://apps.bdimg.com/libs/jquery/2.1.1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script language=&quot;JavaScript&quot;&gt; var screenW=parseInt($(&quot;.screen&quot;).width()); //获取screen窗口的宽度 var screenH=parseInt($(&quot;.screen&quot;).height()); //获取screen窗口的高度 $(&quot;#btn&quot;).bind(&quot;click&quot;,auto); //bind(&quot;e&quot;.function)此处function只能写函数名auto,不能写auto() document.onkeydown=function (e) { //绑定点击和回车 if (e.keyCode == 13){ auto(); //此处需写auto() } } function auto() { var inp = $(&quot;#in&quot;).val(); //val()获取input或hidden或摁键对象的值 $(&quot;#in&quot;).val(&quot;&quot;); //val(&quot;&quot;)给input或hidden或摁键对象赋一个空值,只使用input或hidden对象，起清空作用 var newspan = $(&quot;&lt;span id=&apos;spa&apos;&gt;&lt;/span&gt;&quot;); //此处设置类或ID方便在CSS文件中进行设置 newspan.text(inp); var top = parseInt(screenH*(Math.random())); //获取随机高度 newspan.css({&quot;color&quot;:getRandomColor(),&quot;top&quot;:top}); //设置随机颜色和高度 $(&quot;.screen&quot;).append(newspan); //将输入内容添加到screen newspan.animate({&quot;right&quot;:screenW+200},10000,&quot;linear&quot;,function(){ $(this).remove(); //左移screenW+200px的动画效果，此处200与前面对应，执行完毕后内容移除 }); } function getRandomColor(){ //获取随机颜色 return &apos;#&apos; + (function(h){ return new Array(7 - h.length).join(&quot;0&quot;) + h })((Math.random() * 0x1000000 &lt;&lt; 0).toString(16)); } &lt;/script&gt; &lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[搭建属于自己的博客hexo]]></title>
      <url>%2F2017%2F01%2F15%2Fbuildhexo%2F</url>
      <content type="text"><![CDATA[博客是个好东西啊，很多时候遇到难以解决的技术问题，都是在别人的博客上找到答案的，浏览别人的博客可以学到很多知识。身边认识的大牛都有自己的专属博客，我也想学着折腾一番，也总结了一些经验。 注册GitHub账号 号称全球最大的同性交友网站，作为一个程序员，一个GitHub账号是必须的。 新建仓库 仓库名称格式是username.github.io 注意，此处username要对应你的GitHub用户名 安装node.js 安装nodejs时官方有.msi后缀和.exe后缀两种文件 。其中.msi文件直接下载安装，已经自动配置好环境，.exe文件需要手动配置环境 。若需要安装.exe可以参考我的另一篇博客。官网下载速度略慢，可用淘宝镜像。 安装Git 去官网或者常用的下载软件的网站都可以下载，安装的时候一路next即可。 安装成功之后运行Git Bash 初始化设置$ git config --global user.name “your name” $ git config --global user.email “your email” 注意，此时输入的email必须与注册GitHub账号的邮箱一致 生成密钥$ ssh-keygen -t rsa -C “your email” 按三个回车，密码为空 得到两个文件 id_rsa和id_rsa.pub （这两个文件一般生成在c/user/administrator/ssh文件夹） 添加密钥 打开你的GitHub找到 ssh and gpg key 点击 new ssh key 刚才得到的id_rsa.pub就是要添加的密钥（添加方法：可将id_rsa.pub文件直接拖入浏览器，出现一串字符，将字符copy到需要填写的地方即可） 测试： $ ssh git@github.com 成功后，GitHub上的ssh小钥匙变成绿色 搭建hexo 新建一个文件夹存放你的hexo相关文件（我将它命名为blog） 安装：$ npm install -g hexo 初始化:$ cd blog $ hexo init 如果你cd进入blog之后，执行的是$ hexo init blog,将自动在blog文件夹下生成另一个blog文件，造成混乱 以下命令都在blog中执行 安装插件：$ npm install hexo-generator-index --save #索引生成器 $ npm install hexo-generator-archive --save #归档生成器 $ install hexo-generator-category --save #分类生成器 $ npm install hexo-generator-tag --save #标签生成器 $ npm install hexo-server --save #本地服务 $ npm install hexo-deployer-git --save #hexo通过git发布（必装） $ npm install hexo-renderer-marked@0.2.7--save #渲染器 $ npm install hexo-renderer-stylus@0.3.0 --save #渲染器 生成静态页面$ hexo generate #简写 $ hexo g 本地启动$ hexo server #简写 $ hexo s 浏览器输入http://localhost:4000即可看到效果。 发布 找到blog根目录下的_config.yml文件，找到下面的deploy: 并更改为 deploy: type: git repo: https://github.com/Wanghan0/Wanghan0.github.io.git #建好的仓库地址.git branch: master 注意冒号后面有一个字符的空格即英文输入下的一个空格 更改完毕执行下列代码 $ hexo g #生成 $ hexo d #发布 #两行简写 $ hexo d -g 对blog中文件做了更改或者发布文章，都要执行这两行代码才能更新到你的博客好啦现在你可以参观你的博客啦，你的地址就是 https://your_github_username.github.io 写文章编辑器下载Markdown编辑器，windows下推荐MarkdownPad 新建文章在命令行模式下cd至博客的根目录，然后执行以下代码 $ hexo new &quot;postName&quot; 打开刚刚生成的文件 title: postName #文章页面上的显示名称，可以任意修改 date: 2016-02-18 15:30:16 tags: #文章标签，可空，多标签请用格式[tag1,tag2,tag3] categories: #文章分类目录，可空 --- 此处编辑正文 注意冒号后面一个字符的空格 文章摘要如果不想自己的文章在主页全部显示，可在截断处添加 &lt;!--more--&gt; 更多markdown语法 发布文章$ hexo clean $ hexo g $ hexo d 至此，第一篇博文完成 搭建这个博客花了我两天多时间，其实你看这个搭建的步骤并不是很麻烦，而且很多人本来就有github账号，也安装过git,那么搭建起hexo来还不是两行代码的事儿。但是我好菜，我的大部分时间竟然花在安装nodejs上面，最后发现是电脑系统有问题，嗨呀，好气呀，重做系统之后两个小时就装好了。不过如果你是第一次接触hexo总是要摸索一下的，碰到问题也没关系，多百度，多请教别人，只要坚持下来就总会解决的。我这种菜鸡都搭好了，你有什么理由不成功？]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[安装nodejs.exe及其环境配置]]></title>
      <url>%2F2017%2F01%2F14%2F2017-1-14%2F</url>
      <content type="text"><![CDATA[安装nodejs时官方有.msi后缀和.exe后缀两种文件 。其中.msi文件直接下载安装，已经自动配置好环境，.exe文件需要手动配置环境 。然而我在安装.msi文件时出现了进度条回滚的现象，提示 your system has not been modified，关闭杀毒软件，防火墙等保护软件再安装也不起效，尝试很多次都安装失败。于是只能尝试安装.exe文件手动配置,下面就是我的一些安装经验。 任意盘新建一个文件夹，我在D盘新建名为nodejs的文件夹 官网下载.exe文件，存入nodejs文件夹 下载npm文件，解压到nodejs文件夹，得到 node_modules文件与npm.cmd指令文件 配置环境 新建两个变量分别为:NODEJS_PATH与NODEJS_MODULE，NODEJS_PATH指定的是我本地的nodejs目录，NODEJS_MODULE指定的是node_modules目录附 配置方法 重新进nodejs目录，输入 node -v如果输出nodejs的版本则安装成功，npm同理附如何使用cmd进入文件目录 这样就大功告成啦 然而我从cmd验证node,npm都安装成功，git bash上却检测不到npm，环境变量也都设置好了，折腾了一整天都没解决。那天，我坐在电脑前思考人生，我想，我可能是装了假系统。 重做了系统之后直接安装.msi，麻利儿装好，一切都很正常，可见，装一个正版的系统有多么的重要。 我虽然是以这样的方式解决了问题，但是安装nodejs.exe的方法原则上是没错的，如果你的系统没有什么问题的话应该有一些参考价值，但是话又说回来，如果你的系统没有问题，那么从一开始就不会出现进度条回滚的现象，嘻嘻。]]></content>
    </entry>

    
  
  
</search>
