<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[详解绝对定位和相对定位]]></title>
      <url>%2F2017%2F04%2F25%2Fcss-position%2F</url>
      <content type="text"><![CDATA[上一篇博文中对元素的居中方式进行了总结，其中很多方法中都用到了相对定位和绝对定位，关于这两种定位方式确实是CSS中的一大难点，如果不能深入了解这两种定位方式，进行页面排版时就容易出现混乱，所以今天我对position的所有属性取值进行一个总结，重点剖析绝对定位和相对定位之间的联系和区别。 position的不同取值 不管是哪种定位，都必须有一个参照物，理清参照物我们就对这些定位方式了解了一半。 static，默认值。位置设置为static的元素，它始终会处于页面流给予的位置（static 元素会忽略任何 top、bottom、left、right和z-index 声明）。 inherit，规定应该从父元素继承 position 属性的值。但是任何的版本的 Internet Explorer （包括 IE8）都不支持属性值 “inherit”。 fixed，生成绝对定位的元素，可定位于相对于浏览器窗口的指定坐标。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。不论窗口滚动与否，元素都会留在那个位置。 absolute，生成绝对定位的元素，相对于距该元素最近的已定位（position不为static）的祖先元素进行定位。此元素的位置可通过 “left”、”top”、”right” 以及 “bottom” 属性来规定。 relative，生成相对定位的元素，相对于该元素在文档中的初始位置进行定位。通过 “left”、”top”、”right” 以及 “bottom” 属性来设置此元素相对于自身位置的偏移。 相对定位relative 相对定位的参照物是它本身 每一个元素都可以看作一个盒子，文档流就是由这些盒子堆砌而成，而每个盒子都在这个文档流中占据了一个位置，如果我们把这个盒子设置成相对定位，那么就可以拿起这个盒子相对于它原来所占据的位置向别的地方移动，如设置left:50px就是相对于盒子原来位置向左移动了50个像素，我们用具体的例子来说明。下面是一个所有元素都没有设置过任何定位方式的原始页面布局。 我们把box-2设置成相对定位并向左移动60像素，向下移动120像素。 .box-2{ background-color: #00A5FF; position: relative; left: 110px; top:60px; } 得到下面的效果 从上图我们可以发现box-2相对于它原来的位置向下且向右移动了，并且原来的位置留下了一片空白，但是其他的元素并没有占据它，说明元素设置相对定位后，可以相对于其在普通流中的位置偏移，原本所占的空间仍保留。 同时我们从图上可以看出，box-2移动之后覆盖了其他的元素，这说明当元素被设置相对定位后，将激活z-index属性，其层叠级别高于原本的文档流。此时如果给box-5也设置 position: relative，那么box-5又会覆盖box-2。绝对定位absolute 绝对定位的参照物是相对于该元素最近的已定位的祖先元素，如果没有一个祖先元素设置定位，那么参照物是body。 绝对定位与相对定位的一大不同之处就是，当我们把一个元素设置成相对定位，那么这个元素将会脱离文档流，漂浮在文档流上方，并且后面的元素将会填充它原来的位置。绝对定位元素根据它的参照物移动自己的位置，而参照物则需要根据它祖先元素的定位设置来确定。我们就用实例说明绝对定位的特点和需要注意的地方。下面是一个所有元素都没有设置过任何定位方式的原始页面布局。 祖先元素都没有设置定位，元素相对于body转移位置。给box-2设置成position: absolute; .box-2{ background-color: #00A5FF; position: absolute; } 得到下面的效果 我们可以看到最后一个box存在的位置空了出来，这是因为box-2脱离文档流漂浮到文档上方，并且后面的元素填补了上去，说明元素设置绝对定位后脱离文档流，后面的元素将填补它的位置。 接着你可能就会发现box-3失踪了，其实它没有失踪，它是在box-2下面，就像相对定位一样，当元素被设置绝对定位后，将激活z-index属性，其层叠级别高于原本的文档流。 你可能会问了，不是说祖先元素都没有定位时，元素会相对于body来改变自己的位置吗，为什么它还是飘在原来的位置，而没有飘到body顶头呢，那么请看，我把left和top属性加上会出现什么样的结果。 .box-2{ background-color: #00A5FF; position: absolute; left: 0px; top:0px; } 得到下面的效果 现在可以看到它与body顶头了，因为光设置一个元素的相对定位它只会漂浮到原来位置的上空，并不会漂浮到参照物的文档流最前方，而只有设置了left、top、right、bottom这些参数的时候才能激活它相对于参照物移动的效果。 祖先元素grandpa设置定位，元素相对于grandpa转移位置。 .grandpa{ background-color: #55a532; height: 500px; width: 600px; margin: 40px; position: relative; } .box-2{ background-color: #00A5FF; position: absolute; left: 20px; top:20px; } 得到下面的效果 祖先元素father设置定位，元素相对于father转移位置。 .father{ background-color: #55a532; height: 400px; width: 500px; margin: 50px; position: relative; } .box-2{ background-color: #00A5FF; position: absolute; left: 20px; top:20px; } 得到下面的效果 父元素son以及祖先元素father、grandpa都设置定位，元素相对于son转移位置。 .grandpa,.father,.son{ position: relative; } .box-2{ background-color: #00A5FF; position: absolute; left: 20px; top:20px; } 得到下面的效果 当祖先元素不止一个设置了定位的时候，选择最近的一个作为参照物。 小结现在你应该就能明白为什么上一篇博文中那么多居中方式都要设置其父元素的position为relative了吧，其实虽然absolute要求的是祖先元素的定位方式是除static都可以，但是最好还是设置成相对定位，因为你只设置relative而不设置left、top等参数的话对元素自身和其他元素是没有影响的，但如果你设置成fixed，元素就有可能受到浏览器窗口的影响（如果有特殊需要当然可以使用），而你设置成inherit也没有什么意义，况且浏览器对它的支持性也不是很好，显然用来限制absolute的话用relative是最合适的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS各种居中实现方式]]></title>
      <url>%2F2017%2F04%2F24%2Fcss-center%2F</url>
      <content type="text"><![CDATA[很多人刚学CSS的时候可能会觉得它很简单，心想不就是一个“背”字吗，把这些样式全记下不就行了吗？其实你一段时间之后就会明白，背是远远不够的，你需要弄清每一个属性的不同值分别得到什么效果，几个属性的组合又会带来什么结果，只有由内而外地理解这些属性，才能找到最便捷的方法达到你想要的效果，理解不是背出来的，是无数次的实践和踩坑得到的。 CSS居中是每次布局都需要面对的问题，我也是踩了无数次的坑才得出一点感悟和经验，今天我就对它做个总结，我相信一个全面的总结会对以后的学习和实践带来很大的帮助。 内联元素 内联元素的特点 和其他元素都在一行上 设置高度height 无效，可以通过line-height来设置 设置margin和padding只有左右有效，上下无效 宽度就是它的文字或图片的宽度，不可改变 内联元素只能容纳文本或者其他内联元素 以下实例都是基于下面的html代码： &lt;div class=&quot;out&quot;&gt; &lt;span class=&quot;in&quot;&gt; 居中元素 &lt;/span&gt; &lt;/div&gt; 水平居中 父元素样式设置为text-align:center，里面包含的行内元素居中,如果父元素内部还存在包含文字且不定宽的块元素，那么这个块元素也会居中。 .out{ text-align: center; } 父元素样式设置为display:flex; justify-content:center，里面包含的行内元素居中。 .out{ display:flex; justify-content:center } 垂直居中 单行文本：可将其父元素的高度和行高设置为相等的值 height = line-height .out{ height: 100px; line-height: 100px; } 多行文本：用一个span标签将所有的文字封装起来，再用一个容器包裹span，设置属性display: table-cell;vertical-align: middle。这种方法同样适用于使图片居中。 .out{ display: table-cell; vertical-align: middle; } 父元素样式设置为display: flex;align-items: center，里面包含的行内元素居中。 .out{ height: 100px; line-height: 100px; } 父元素样式设置为display:flex; align-items: center，里面包含的行内元素居中。 .out{ display:flex; align-items: center; } 块级元素 块级元素的特点 总是在新行上开始，占据一整行 高度，行高以及外边距和内边距都可控制 宽度缺省是它的容器的100%，除非设定一个宽度 它可以容纳内联元素和其他块元素 以下实例都基于下面的html代码： &lt;div class=&quot;out&quot;&gt; &lt;div class=&quot;in&quot;&gt; 居中元素 &lt;/div&gt; &lt;/div&gt; 水平居中定宽块级元素水平居中 父元素样式设置为display:flex; justify-content:center，则里面包含的块元素居中 .out{ display:flex; justify-content:center; } 该元素样式设置为 margin：0 auto； .in{ width: 100px; margin: 0 auto; } 该元素样式设置为 position: relative;left: 50%；margin-left: -0.5*width（负的该元素宽度的一半） .in{ width: 100px; position: relative; left: 50%; margin-left: -50px; } 上述方法把relative改为absolute也同样适用，根据实际情况选择适合自己的方法。 .in{ width: 100px; position: absolute; left: 50%; margin-left: -50px; } 不定宽块级元素水平居中 对于包含文字的块元素可将其父元素设置为text-align:center .out{ text-align:center; } 若不包含文字，可把该块级元素变成行内元素，即设置display:inine，再给其父元素设置text-align:center .out{ text-align:center; } .in{ display:inine; } 父元素样式设置为display:flex; justify-content:center，则里面包含的块元素居中 .out{ display:flex; justify-content:center; } 该元素样式设置为 position: absolute;left: 50%;transform: translate(-50%,0) .in{ position: absolute; left: 50%; transform: translate(-50%,0); } 垂直居中定高块级元素垂直居中 父元素样式设置为display:flex; align-items: center，则里面包含的块元素居中 .out{ display:flex; align-items: center; } 该元素样式设置为 position: relative;top: 50%；margin-top: -0.5*height（负的该元素高度的一半） .in{ height:100px; position: relative; top: 50%; margin-top:-50px; } 该元素的父元素的position值设置为relative，将该元素样式设置为position: absolute;top:50%;margin-top: -0.5*height .out{ position: relative; } .in{ height:100px; position: absolute; top:50%; margin-top: -50px } 该元素的父元素的position值设置为relative，将该元素样式设置为position: absolute;top:0;bottom: 0;left: 0;right: 0;margin: auto; .out{ position: relative; } .in{ height:100px; position: absolute; top:0; bottom: 0; left: 0; right: 0; margin: auto; } 不定高块级元素垂直居中 父元素样式设置为display:flex; align-items: center，则里面包含的块元素居中 .out{ display:flex; align-items: center; } 该元素样式设置为 position: relative;top: 50%;transform: translate(0,-50%) .in{ position: relative; top: 50%; transform: translate(0,-50%); } 该元素的父元素的position值设置为relative，将该元素样式设置为position: absolute;top:50%;translate(0,-50%) .out{ position: relative; } .in{ position: absolute; top: 50%; transform: translate(0,-50%); } 小结 总结到这里就会发现令元素居中的办法千奇百怪，其中无论水平还是垂直，无论有没有指定宽高，总能奏效的办法就是display:flex办法，这也是flex布局的优势之一，有时候使用flex布局甚至比bootstrap这种框架更加顺手，有机会我也会对flex做个总结。 另外在上面的很多居中的办法中都用到了position: absolute，但是其实不建议经常使用绝对定位进行布局，因为它脱离了文档流，并且页面复杂的话也会对其他元素造成影响，有时改变窗口大小布局也会受到影响。因为关于position的不同取值带来的效果经常使人困扰，后面我也会对它进行总结。 还有，居中的办法有这么多，但并不代表你需要懂得每一种，甚至去学会一些奇怪或者复杂的居中方式，而是在布局的过程中选择最适合、最简单、你用的最顺手的方法实现你想要的效果，俗话说黑猫白猫，能抓住耗子的就是好猫，居中方式也是一样的道理。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[谈谈我对盒模型的理解]]></title>
      <url>%2F2017%2F03%2F31%2Fcss-box%2F</url>
      <content type="text"><![CDATA[盒子是无处不在的。html任何一个元素都可以看作一个盒子，这个盒子不可见，但是它存在于页面的每个角落，也正是由于它不可见、不直观，很多人在初学CSS的时候不能透彻得理解盒模型的概念，导致在页面布局中出现各种各样的问题。 盒子模型简介 上面是一个盒子模型图，一个盒子包括了content（实际内容）、border（边框）、padding（内边距）和margin（外边距）。 content（实际内容）盒子的内容，显示文本和图像。我们给元素设置的width和height其实是content的宽高， 如果指定高度大于显示内容所需高度，多余的高度会产生类似内边距一样的效果；如果指定高度小于显示内容所需高度，会出现滚动条。如果元素内容的高度大于元素框的高度，浏览器的具体行为取决于overflow属性。 border（边框）元素的边框是围绕元素内容的内边距的一条或多条线。边框由粗细、样式和颜色三部分组成。 padding（内边距）清除内容周围的区域，内边距是透明的，取值不能为负，受盒子的Background属性影响，padding是有背景的。 margin（外边距）在元素外创建额外的空白，空白通常指不能放其他元素的区域，而且在这个区域中可以看到父元素的背景（padding所带的是本身的背景而非父元素）。margin经常取负值实现定位的作用。外边距有一个合并问题，经常使人们混淆，简单来说，外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。 两种盒子模型其实盒模型有两种，分别是ie盒子模型（IE6以下版本浏览器)和标准w3c盒子模型，区别在于前者content的宽度和高度包括了border和padding。margin（外边界）虽不可见，但是它确实在文档中占据了空间，我们要区分两个概念即：盒子所占空间（计入margin ）和盒子实际的大小（不计入margin） 。 实例区分两种盒模型下面举个例子来区分两种盒模型：一个盒子的 margin 为 20px，border 为 2px，padding 为 10px，content 的宽为 200px、高为 50px。 ie盒子模型盒子所占空间：width=20ｘ2+200=240 height=20ｘ2+50=90 盒子实际大小：width=200 height=50 标准w3c盒子模型盒子所占空间：width=20ｘ2+2ｘ2+10ｘ2+200=264 height=20ｘ2+２ｘ2+10ｘ2 +50=114 盒子实际大小：width=200 +2ｘ2+10ｘ2 =224 height=50+2ｘ2+10ｘ2=74 解释到这里，有的人可能会想起CSS3里面有个叫做box-sizing的属性，咦？两个盒模型不就是它不同取值下的效果吗？那我恭喜你，你说对了～ box-sizing和两种盒模型不得不说的事box-sizing有三个取值： 1、content-box:使元素遵循标准 w3c 盒子模型（默认值）。 2、border-box:使元素遵循ie 盒子模型。 3、 inherit： 规定应从父元素继承 box-sizing 属性的值。 那么我可以用box-sizing的不同取值让大家直观地理解两个盒子的区别，也顺带理解这个属性，下面是需要用到的html代码，方便大家看得清楚，我给盒子外面添加一个宽高各500px的灰色背景。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;盒模型&lt;/title&gt; &lt;link href=&quot;盒模型.css&quot; type=&quot;text/css&quot; rel=&quot;stylesheet&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;bg&quot;&gt; &lt;div class=&quot;box&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; box-sizing：content-box.box{ background-color: #91D4DA; width: 300px; height: 300px; padding: 20px; border: 10px solid #5B5B5B; box-sizing: content-box; /*默认值，可以不写*/ } 下面改变padding和border的值 .box{ background-color: #91D4DA; width: 300px; height: 300px; padding: 50px; border: 20px solid #5B5B5B; box-sizing: content-box; /*默认值，可以不写*/ } 大家可以发现，元素盒子的实际宽度是随padding和border改变的。 box-sizing：border-box： .box{ background-color: #91D4DA; width: 300px; height: 300px; padding: 20px; border: 10px solid #5B5B5B; box-sizing: border-box; } 下面改变padding和border的值 .box{ background-color: #91D4DA; width: 300px; height: 300px; padding: 50px; border: 20px solid #5B5B5B; box-sizing: border-box; } 发现区别了吧，当你遵循ie盒子模型时，不管你如何设置padding和border（小于width/2），它只在盒子里面伸缩，不影响整体的宽高，这个border-box是不是在某些时候非常好用？但也不能盲目地用，因为它会影响content，如果padding和border太大，会把内容挤掉的。 现在还在用IE6以下的浏览器的用户已经很少了，所以目前浏览器大部分元素都是基于W3C标准盒子模型 上。所以我们平常说的盒子模型一般就是标准 w3c 盒子模型 （但对于input、button元素默认border-box ，还是基于传统的ie 盒子模型 ）。一定有人会问，那我们怎样让我们的元素都遵循W3C标准盒子模型呢？哈哈，看看你html的文件头部是不是有一个&lt;!DOCTYPE html&gt;，有这个，就说明你已经遵循W3C标准盒子模型了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一个简易弹幕]]></title>
      <url>%2F2017%2F02%2F11%2Fdanmu%2F</url>
      <content type="text"><![CDATA[这是一个用jquery写的弹幕，下面是一点心得。编写jquery的要点在于以下几个方面：1.获取随机高度和随机颜色2.绑定点击和回车事件3.获取输入内容并以动画形式添加到窗口下面贴出完整代码，一些细节都会提到 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;弹幕&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; body{ background-color: gainsboro; } .main{ margin:auto; background-color:rgba(71,71,71,0.95); height: 500px; width: 60%; } .screen{ background-color: antiquewhite; margin: 0; padding: 0; width: 100%; height: 90%; position: relative; overflow: hidden; /*overflow: hidden对screen外的部分进行裁剪，弹幕内容只出现在screen中*/ } .input{ margin-left: 17%; margin-top: 10px; padding-left: 2%; width: 50%; height: 30px; border-radius: 10px 0 0 10px; border: none; } .button{ position: relative; top:-32px; padding: 0; margin-left: 69%; height: 32px; width: 10%; border-radius: 0 10px 10px 0; background-color: rgba(80,188,50,0.95); border: none; color: white; } .button:hover{ background-color: rgba(66,156,42,0.95); cursor: pointer; } #spa{ position: absolute; /*在JS中定义top,right要建立在 position: absolute基础上*/ width: 200px; /*设置弹幕的宽度*/ right: -200px; /*弹幕从screen边界右边200px处开始，与宽度相等，当大于宽度时会延迟到来时间，小于时会从screen内部开始*/ } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;screen&quot;&gt; &lt;/div&gt; &lt;div class=&quot;foot&quot;&gt; &lt;input id=&quot;in&quot; class=&quot;input&quot; type=&quot;text&quot; placeholder=&quot;说点什么...&quot;&gt; &lt;button id=&quot;btn&quot; class=&quot;button&quot; type=&quot;button&quot;&gt;发送&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;script language=&quot;javascript&quot; src=&quot;http://apps.bdimg.com/libs/jquery/2.1.1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script language=&quot;JavaScript&quot;&gt; var screenW=parseInt($(&quot;.screen&quot;).width()); //获取screen窗口的宽度 var screenH=parseInt($(&quot;.screen&quot;).height()); //获取screen窗口的高度 $(&quot;#btn&quot;).bind(&quot;click&quot;,auto); //bind(&quot;e&quot;.function)此处function只能写函数名auto,不能写auto() document.onkeydown=function (e) { //绑定点击和回车 if (e.keyCode == 13){ auto(); //此处需写auto() } } function auto() { var inp = $(&quot;#in&quot;).val(); //val()获取input或hidden或摁键对象的值 $(&quot;#in&quot;).val(&quot;&quot;); //val(&quot;&quot;)给input或hidden或摁键对象赋一个空值,只使用input或hidden对象，起清空作用 var newspan = $(&quot;&lt;span id=&apos;spa&apos;&gt;&lt;/span&gt;&quot;); //此处设置类或ID方便在CSS文件中进行设置 newspan.text(inp); var top = parseInt(screenH*(Math.random())); //获取随机高度 newspan.css({&quot;color&quot;:getRandomColor(),&quot;top&quot;:top}); //设置随机颜色和高度 $(&quot;.screen&quot;).append(newspan); //将输入内容添加到screen newspan.animate({&quot;right&quot;:screenW+200},10000,&quot;linear&quot;,function(){ $(this).remove(); //左移screenW+200px的动画效果，此处200与前面对应，执行完毕后内容移除 }); } function getRandomColor(){ //获取随机颜色 return &apos;#&apos; + (function(h){ return new Array(7 - h.length).join(&quot;0&quot;) + h })((Math.random() * 0x1000000 &lt;&lt; 0).toString(16)); } &lt;/script&gt; &lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[搭建属于自己的博客hexo]]></title>
      <url>%2F2017%2F01%2F15%2Fbuildhexo%2F</url>
      <content type="text"><![CDATA[博客是个好东西啊，很多时候遇到难以解决的技术问题，都是在别人的博客上找到答案的，浏览别人的博客可以学到很多知识。身边认识的大牛都有自己的专属博客，我也想学着折腾一番，也总结了一些经验。 注册GitHub账号 号称全球最大的同性交友网站，作为一个程序员，一个GitHub账号是必须的。 新建仓库 仓库名称格式是username.github.io 注意，此处username要对应你的GitHub用户名 安装node.js 安装nodejs时官方有.msi后缀和.exe后缀两种文件 。其中.msi文件直接下载安装，已经自动配置好环境，.exe文件需要手动配置环境 。若需要安装.exe可以参考我的另一篇博客。官网下载速度略慢，可用淘宝镜像。 安装Git 去官网或者常用的下载软件的网站都可以下载，安装的时候一路next即可。 安装成功之后运行Git Bash 初始化设置$ git config --global user.name “your name” $ git config --global user.email “your email” 注意，此时输入的email必须与注册GitHub账号的邮箱一致 生成密钥$ ssh-keygen -t rsa -C “your email” 按三个回车，密码为空 得到两个文件 id_rsa和id_rsa.pub （这两个文件一般生成在c/user/administrator/ssh文件夹） 添加密钥 打开你的GitHub找到 ssh and gpg key 点击 new ssh key 刚才得到的id_rsa.pub就是要添加的密钥（添加方法：可将id_rsa.pub文件直接拖入浏览器，出现一串字符，将字符copy到需要填写的地方即可） 测试： $ ssh git@github.com 成功后，GitHub上的ssh小钥匙变成绿色 搭建hexo 新建一个文件夹存放你的hexo相关文件（我将它命名为blog） 安装：$ npm install -g hexo 初始化:$ cd blog $ hexo init 如果你cd进入blog之后，执行的是$ hexo init blog,将自动在blog文件夹下生成另一个blog文件，造成混乱 以下命令都在blog中执行 安装插件：$ npm install hexo-generator-index --save #索引生成器 $ npm install hexo-generator-archive --save #归档生成器 $ install hexo-generator-category --save #分类生成器 $ npm install hexo-generator-tag --save #标签生成器 $ npm install hexo-server --save #本地服务 $ npm install hexo-deployer-git --save #hexo通过git发布（必装） $ npm install hexo-renderer-marked@0.2.7--save #渲染器 $ npm install hexo-renderer-stylus@0.3.0 --save #渲染器 生成静态页面$ hexo generate #简写 $ hexo g 本地启动$ hexo server #简写 $ hexo s 浏览器输入http://localhost:4000即可看到效果。 发布 找到blog根目录下的_config.yml文件，找到下面的deploy: 并更改为 deploy: type: git repo: https://github.com/Wanghan0/Wanghan0.github.io.git #建好的仓库地址.git branch: master 注意冒号后面有一个字符的空格即英文输入下的一个空格 更改完毕执行下列代码 $ hexo g #生成 $ hexo d #发布 #两行简写 $ hexo d -g 对blog中文件做了更改或者发布文章，都要执行这两行代码才能更新到你的博客好啦现在你可以参观你的博客啦，你的地址就是 https://your_github_username.github.io 写文章编辑器下载Markdown编辑器，windows下推荐MarkdownPad 新建文章在命令行模式下cd至博客的根目录，然后执行以下代码 $ hexo new &quot;postName&quot; 打开刚刚生成的文件 title: postName #文章页面上的显示名称，可以任意修改 date: 2016-02-18 15:30:16 tags: #文章标签，可空，多标签请用格式[tag1,tag2,tag3] categories: #文章分类目录，可空 --- 此处编辑正文 注意冒号后面一个字符的空格 文章摘要如果不想自己的文章在主页全部显示，可在截断处添加 &lt;!--more--&gt; 更多markdown语法 发布文章$ hexo clean $ hexo g $ hexo d 至此，第一篇博文完成 搭建这个博客花了我两天多时间，其实你看这个搭建的步骤并不是很麻烦，而且很多人本来就有github账号，也安装过git,那么搭建起hexo来还不是两行代码的事儿。但是我好菜，我的大部分时间竟然花在安装nodejs上面，最后发现是电脑系统有问题，嗨呀，好气呀，重做系统之后两个小时就装好了。不过如果你是第一次接触hexo总是要摸索一下的，碰到问题也没关系，多百度，多请教别人，只要坚持下来就总会解决的。我这种菜鸡都搭好了，你有什么理由不成功？]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[安装nodejs.exe及其环境配置]]></title>
      <url>%2F2017%2F01%2F14%2F2017-1-14%2F</url>
      <content type="text"><![CDATA[安装nodejs时官方有.msi后缀和.exe后缀两种文件 。其中.msi文件直接下载安装，已经自动配置好环境，.exe文件需要手动配置环境 。然而我在安装.msi文件时出现了进度条回滚的现象，提示 your system has not been modified，关闭杀毒软件，防火墙等保护软件再安装也不起效，尝试很多次都安装失败。于是只能尝试安装.exe文件手动配置,下面就是我的一些安装经验。 任意盘新建一个文件夹，我在D盘新建名为nodejs的文件夹 官网下载.exe文件，存入nodejs文件夹 下载npm文件，解压到nodejs文件夹，得到 node_modules文件与npm.cmd指令文件 配置环境 新建两个变量分别为:NODEJS_PATH与NODEJS_MODULE，NODEJS_PATH指定的是我本地的nodejs目录，NODEJS_MODULE指定的是node_modules目录附 配置方法 重新进nodejs目录，输入 node -v如果输出nodejs的版本则安装成功，npm同理附如何使用cmd进入文件目录 这样就大功告成啦 然而我从cmd验证node,npm都安装成功，git bash上却检测不到npm，环境变量也都设置好了，折腾了一整天都没解决。那天，我坐在电脑前思考人生，我想，我可能是装了假系统。 重做了系统之后直接安装.msi，麻利儿装好，一切都很正常，可见，装一个正版的系统有多么的重要。 我虽然是以这样的方式解决了问题，但是安装nodejs.exe的方法原则上是没错的，如果你的系统没有什么问题的话应该有一些参考价值，但是话又说回来，如果你的系统没有问题，那么从一开始就不会出现进度条回滚的现象，嘻嘻。]]></content>
    </entry>

    
  
  
</search>
