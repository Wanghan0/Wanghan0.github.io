<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[创建对象（三）——构造函数和原型模式的组合使用以及其他模式]]></title>
      <url>%2F2017%2F05%2F17%2Fjs-object3%2F</url>
      <content type="text"><![CDATA[上篇博文我们说到，单独使用原型模式存在着两个弊端：一个是当原型的属性值是引用类型值的时候，在实例上操作属性会修改原型对象中的属性值；其二是不能利用传入参数创建具有特定属性值的实例。而组合使构造函数和原型模式就能克服这两个弊端。 组合使用构造函数模式和原型模式目前使用最广泛、认同度最高的创建自定义类型的方法就是组合使用构造函数模式和原型模式。构造函数用于定义实例属性，原型模式用于定义方法和共享的属性。123456789101112131415161718function Person(a,b) &#123; this.name = a; this.age = b; this.friends = ["zhangmin","yangfan"]&#125;Person.prototype=&#123; constructor: Person, getName : function () &#123; console.log(this.name); &#125;&#125;;var fun1 = new Person("wanghan",20);var fun2 = new Person("Tom",26);fun1.friends.push("Van");console.log(fun1.friends); //["zhangmin", "yangfan", "Van"]console.log(fun2.friends); //["zhangmin", "yangfan"]console.log(fun1.name); //wanghanconsole.log(fun2.name); //Tom 例子非常简单，这里就不作过多解释了。 动态原型模式这个模式在构造函数中完成对原型的创建，具有更好的封装性，又保持了同时使用构造函数和原型的优点。12345678910111213141516function Person(a,b) &#123; this.name = a; this.age = b; if (typeof this.getName !="function")&#123; Person.prototype.getName = function () &#123; console.log(this.name); &#125;; Person.prototype.getAge = function () &#123; console.log(this.age); &#125; &#125;&#125;var fun1 = new Person("wanghan",20);var fun2 = new Person("Tom",26);fun1.getName(); //wanghanfun2.getAge(); //26 这个方法的重点在于构造函数中的if语句。在函数首次调用时，也就是创建实例fun1时判断是否存在getName方法，发现不存在后开始初始化原型对象，为原型添加了两个方法。创建第二个实例fun2时，因为getName方法已经存在，所以不再执行if语句，所以我们说，if语句中的代码只在构造函数第一次调用时执行一次。并且if中的判断条件只需要写其中一个方法或者属性就可以检查到原型有没有初始化。使用这个模式时，不能使用对象字面量重写原型。 寄生构造函数模式这个模式跟工厂模式非常类似，但它又是使用操作符new调用的构造函数。1234567891011function Person(a,b) &#123; var o =&#123; &#125;; o.name = a; o.age = b; o.getName = function () &#123; console.log(this.name); &#125;; return o;&#125;var fun1 = new Person("wanghan",20);fun1.getName(); //wanghan 构造函数在不返回值的情况下，默认会返回新对象实例。而如果返回了一个值，这个值就会重写调用构造函数返回的值。这个模式并不常用，而且它跟工厂模式一样，不能解决对象识别问题。但是利用这个模式，可以为数组、字符串这种原生引用类型添加额外的方法。 稳妥构造函数模式与寄生构造函数模式类似，但是有两点不同，一是新创建对象的实例方法不引用this，二是不使用操作符new调用构造函数。123456789function Person(a,b) &#123; var o =&#123; &#125;; o.getName = function () &#123; console.log(a); &#125;; return o;&#125;var fun1 = Person("wanghan",20);fun1.getName(); //wanghan 这个模式也不能解决对象识别问题。 小结我们总共讲了八种创建对象的方法，各有各得缺点也各有各的优点。其实方法不在你会多少，而是你遇到一个问题，能快速找到解决这个问题的最佳方法，这才是最重要的，不要成天老整一些花里胡哨的，彰显自己会的多。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[创建对象（二）——原型模式]]></title>
      <url>%2F2017%2F05%2F16%2Fjs-object2%2F</url>
      <content type="text"><![CDATA[理解原型对象我们创建的每一个函数都有一个默认的prototype属性，它指向一个对象，对象中默认的有一个叫做constructor的属性，指向这个函数本身。如上图，右侧的这个方框就是函数function的原型，也就是说prototype属性指向的这个对象就是原型。当构造函数创建出一个新实例后，该实例会默认具有一个__proto__属性，这个属性指向构造函数的原型对象。因此，如果我们把属性和方法都添加到原型对象中，不同的实例就可以访问到相同的属性和方法了。1234567891011121314function Person() &#123;&#125;Person.prototype.name = "wanghan";Person.prototype.age = 20;Person.prototype.getName = function () &#123; console.log(this.name);&#125;;var fun1 = new Person();var fun2 = new Person();console.log(fun1.name); //wanghanconsole.log(fun2.age); //20fun1.getName(); //wanghanfun2.getName(); //wanghanconsole.log(fun1.getName == fun2.getName); //true 我们先声明了一个空的构造函数Person，将一些属性和方法添加到了Person函数的prototype属性中，然后实例化了两个对象，根据后面的输出我们可以确定两个实例访问的是相同的对象，它们共享这些属性和方法。下图展示了例子中各个对象的关系： 实例与原型中属性的纠葛当为对象实例添加一个属性时，这个属性就会屏蔽原型对象中保存的同名属性。换句话说，添加这个属性只会阻止我们去访问原型中的那个属性，但不会修改那个属性。你也可以理解为，当我们访问实例对象时，会优先访问它自身的属性和方法。1234567891011121314function Person() &#123;&#125;Person.prototype.name = "wanghan";Person.prototype.age = 20;Person.prototype.getName = function () &#123; console.log(this.name);&#125;;var fun1 = new Person();var fun2 = new Person();fun1.name = "Tom";console.log(fun1.name); //Tomconsole.log(fun2.name); //wanghanfun1.getName(); //Tomfun2.getName(); //wanghan 在这个例子中，我们给实例fun1添加了属性name=&quot;Tom&quot;。 访问fun1.name时，先在实例fun1中寻找属性name，找到之后返回Tom就不必再搜索原型了。 而访问fun2.name时，先在实例fun2中没有找到属性name，于是搜索原型，结果找到了值为wanghan的属性name，验证了在实例中添加属性不会修改原型中的同名属性。 访问fun1.getName()时，在在实例fun1中没有找到方法getName()，搜索原型找到了这个方法，执行其中的代码，此时方法中的this已经指向了实例（回忆一下操作符new调用构造函数经历的过程），因此输出的是实例属性name的值Tom。 判断属性的位置 hasOwnProperty()方法只在给定属性存在于实例对象中时返回true。 单独使用in操作符时，无论属性存在于实例中还是原型中，只要能够访问到，就会返回true。 如果实例和原型中都存在着一个相同属性，结合这两种方法我们就可以判断，我们访问到的这个同名属性到底是实例中的还是原型中的。12345678910function Person() &#123;&#125;Person.prototype.name = "wanghan";Person.prototype.age = 20;var fun = new Person();fun.name = "Tom";console.log("name" in fun); //trueconsole.log(fun.hasOwnProperty("name")); //true --name来自实例console.log("age" in fun); //trueconsole.log(fun.hasOwnProperty("age")); //false --age来自原型 更简单的原型语法在前面的例子中，我们给原型对象添加对象的时候，输入了好多遍Person.prototype，其实这些不必要的输入都是可以避免的，最常见的方法就是以对象字面量的形式创建对象。12345678910111213function Person() &#123;&#125;Person.prototype=&#123; name: "wanghan", age: 20, getName: function () &#123; console.log(this.name) &#125;&#125;;var fun = new Person();console.log(fun.name); //wanghanconsole.log(fun.age); //20fun.getName(); //wanghan 这样创建对象是不是很轻松，而且输出的结果跟之前相比并没有什么变化。但是这里有一点需要注意，重写原型对象的实质是，我们重建了一个对象赋值给了函数的prototype，所以新建的这个原型对象中默认的constructor属性也是新建的，它不指向构造函数Person，但是必要情况下我们可以手动让它指向Person。12345678910function Person() &#123;&#125;Person.prototype=&#123; constructor: Person, //看这里 name: "wanghan", age: 20, getName: function () &#123; console.log(this.name) &#125;&#125;; 重写原型对象的弊端由于实例与原型之间的松散连接关系，即使我们先创建实例，再给原型对象添加属性，我们也照样可以访问到这些属性。12345function Person() &#123;&#125;var fun = new Person();Person.prototype.name ="wanghan";console.log(fun.name); //wanghan 但是重写原型对象之后就不一样了。12345678function Person() &#123;&#125;var fun = new Person();Person.prototype=&#123; constructor: Person, name: "wanghan"&#125;;console.log(fun.name); //undefined 我们前面说过，重写原型对象实际上是新建了一个新的对象赋值给构造函数的prototype。如果是先创建一个实例，那么实例指向最开始的一个只含有constructor属性的原型对象，即使随后又新建了一个原型对象，它的指向也不会再发生变化。要想解决这个问题就要牢记，要在重写原型对象之后新建实例，这样实例指向的就是重写之后的原型对象。12345678function Person() &#123;&#125;Person.prototype=&#123; constructor: Person, name: "wanghan"&#125;;var fun = new Person();console.log(fun.name); //wanghan 原型对象的问题原型模式也不是没有缺点。 原型中的所有属性和方法都是被实例所共享的，共享方法（函数）是非常合适的，对于那些基本值的属性也还说的过去，但是对于包含引用类型值得属性来说，问题就非常突出了。 123456789101112function Person() &#123;&#125;Person.prototype=&#123; constructor: Person, name: "wanghan", friends: ["zhangmin","yangfan"]&#125;;var fun1 = new Person();var fun2 = new Person();fun1.friends.push("Tom");console.log(fun1.friends); //["zhangmin", "yangfan", "Tom"]console.log(fun2.friends); //["zhangmin", "yangfan", "Tom"] 原型对象中有一个字符串数组，然后创建了两个实例，操作实例fun1向原型对象的数组中又添加了一个字符串Tom，由于数组是引用类型值，并且两个实例共享原型对象中的属性，所以我们刚刚的修改也会在实例fun2中体现出来。这个问题正是我们极少看到有人单独使用原型模式的原因所在。 原型对象直接在原型对象里定义了属性值，使所有实例默认情况下都取得相同的属性值，要克服这一缺点可以组合使用原型模式和构造函数模式。 后记我画框图是用电脑自带的画图软件画的你敢信，举得例子也是自己手打出来的，运行正确之后就剪切到markdown上面。眼看着快要写完了，时间也快凌晨两点了，喜滋滋地准备收尾，谁知道电脑突然一黑，重启了。再次打开markdown之后我就绝望了，就剩下前两段摆在上面。我冷静了二十分钟，发了个朋友圈，然后重写到凌晨四点。嗨呀，好气呀。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[创建对象（一）——工厂模式和构造函数模式]]></title>
      <url>%2F2017%2F05%2F16%2Fjs-object1%2F</url>
      <content type="text"><![CDATA[对象我们常听到一句话：“在javascript中，一切皆是对象”。那么对象是什么呢？ECMA-262把对象定义为：“无序属性的集合，其属性可以包含基本值，对象或者函数”。也就是说对象是一组没有特定顺序的值，它的每个属性或者方法都有一个名字，每个名字都映射到一个值。创建对象有很多种方法，最原始的方法是这样的：12345678910var person = &#123; name: "wanghan", age: "20", getName: function() &#123; console.log(this.name); &#125;&#125;console.log(person.age); //20 访问属性的方式一console.log(person['age']); //20 访问属性的方式二person.getName(); //wanghan 也可以这样写：123456var person = &#123; &#125;; person.name= "wanghan", person.age= "20", person.getName= function() &#123; console.log(this.name); &#125; 虽然这些方式都可以简单的创建一个对象，但是它们都有明显的弊端。假如说我们要创建一组相似的对象，这些对象拥有相同的属性名，只是属性值各不相同，我们用上面的办法就需要重复很多的代码，这显然是不合理的。还好我们有更机智的办法。 工厂模式对于上面创建多个相似对象的问题，我们可以用一个函数来封装它所有的属性，这样我们只要给函数传入不同的参数（属性值），就能轻松创建出一个对象。就像工厂里加工产品一样，只要有一个模子，我们就可以复制出来无数个产品。1234567891011121314function person(a,b) &#123; var o = &#123;&#125;; //这个对象就相当于模子 o.name = a; o.age = b; o.getName=function () &#123; console.log(this.name); &#125;; return o; //函数被调用时就会返回这个对象&#125;var fun = person("wanghan",20);fun.getName(); //wanghanconsole.log(fun.age); //20console.log(fun instanceof Object); //trueconsole.log(fun instanceof person); //false 简单来说，使用工厂模式创建对象的过程就是，在函数内创建一个对象，赋予属性及方法后再将对象返回。但是工厂模式创建的实例类型全都是Object，却不能识别到底是哪种对象类型。instanceof 用于判断一个变量是否是某个对象的实例，从上例最后两行代码就能看出，工厂模式就像暗箱操作，实例不知道自己是被谁创造的。但是好在“构造函数模式”可以解决这个问题。 构造函数模式我们用构造函数重写上面的栗子：123456789101112function Person(a,b) &#123; this.name = a; this.age = b; this.getName = function () &#123; console.log(this.name); &#125;;&#125;var fun = new Person("wanghan",20)fun.getName(); //wanghanconsole.log(fun.age); //20console.log(fun instanceof Object); //trueconsole.log(fun instanceof Person); //true 最后两行代码可以看出，在这个模式中，可以验证fun是构造函数Person的实例,说明了构造函数可以将它的实例标识为一种特定的类型，这正是胜于工厂模式的地方。我们仔细观察构造函数与工厂模式创造的函数的不同之处： 没有显式地创建对象； 直接将属性和方法赋值给了this对象； 没有return语句； 函数首字母大写（为了区别于普通函数）； 调用函数时用到new操作符。 new操作符构造函数跟其他函数的唯一区别，就在于调用它们的方式不同，任何函数，只要通过new操作符来调用，那它就可以作为构造函数。通过new调用函数时会经历以下步骤： 创建一个新对象； 将构造函数的作用域赋值给了新对象（因此this就指向了这个新对象）； 执行构造函数中的代码（为这个新对象添加属性）； 返回新对象 构造函数的问题构造函数模式虽然好用，但也并非没有缺点，它的主要问题就是每个方法要在每个实例上创建一遍。在上面的栗子中，实例fun中创建了一个getName方法，但是如果我们再实例化一个对象，会再次创建一个getName方法，并且这两个同名函数是不相等的。12345678910function Person(a,b) &#123; this.name = a; this.age = b; this.getName = function () &#123; console.log(this.name); &#125;;&#125;var fun = new Person("wanghan",20);var fun2 = new Person("wanghan",20);console.log(fun.getName == fun2.getName); //false 这些getName方法实现的功能是完全一样的，但是由于分别属于不同的实例，就不得不为每个getName分配空间，这显然是不合理的，那要怎么样才能让所有的实例都访问同一个getName方法呢，这就要用到原型模式了。关于原型，且听下回分解。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Ajax]]></title>
      <url>%2F2017%2F05%2F13%2Fjs-Ajax%2F</url>
      <content type="text"><![CDATA[Ajax全称为“Asynchronous Javascript and XML”（异步javascript和XML），它并不是指一种单一的技术，而是有机地利用了一系列交互式网页相关的技术所形成的结合体，它的出现结束了“单击，等待”的传统交互模式，开启了无刷新更新页面的新时代。 Ajax的优点 不需要插件支持ajax不需要任何浏览器插件，就可以被绝大多数的主流浏览器所支持，用户只需要允许javascript在浏览器上执行即可。 优秀的用户体验这是ajax技术的最大优点，能在不刷新整个页面的前提下更新数据，这使得web应用程序能更为迅速地回应用户的操作。 提高web程序的性能与传统模式相比，ajax模式在性能上的最大区别就在于传输数据的方式，在传统模式中，数据是通过提交表单来实现的，而数据获取是靠全页面刷新来重新获取整页的内容。ajax模式只是通过XMLHttpRequest对象向服务器提交希望提交的数据，即按需发送。 减轻服务器和带宽的负担ajax的工作原理相当于在用户和服务器之间加了一个中间层，使用户操作与服务器响应异步化。它在客户端创建ajax引擎，把传统方式下的一些服务器负担的工作转移到客户端，便于客户端资源来处理，减轻服务器和带宽的负担。 Ajax的缺点 破坏浏览器 “后退”按钮的正常功能在ajax中，“前进”和“后退”按钮的功能都会失效。用户经常会遇到这情况，当单击一个按钮触发一个ajax交互后，如果点击“后退”按钮，浏览器会直接后退到前一个页面，而不是仅仅是回退到ajax交互操作前。 需要处理浏览器兼容性问题 创建XMLHttpRequest对象XMLHttpRequest对象简称XHR对象，它是ajax技术的核心，发送异步请求、接收响应及执行回调都是通过它来完成的。ie7+、firefox、opera、chrome和safari都支持原生的XHR对象，在这些现代浏览器中这样创建：1var xhr = new XMLHttpRequest(); 在ie5和ie6中，是以ActiveXObject的方式引入XHR对象的：1var xhr=new ActiveXObject("Microsoft.XMLHTTP"); 如果你既想支持现代浏览器又不想放弃ie5和ie6，那么你需要做一个逻辑判断：123456var xhrif(window.ActiveXObject)&#123;xhr = new ActiveXObject("Microsoft.XMLHTTP")&#125;else if (window.XMLHttpRequest)&#123; xhr = new XMLHttpRequest();&#125; XMLHttpRequest对象的属性readyState该属性表示请求/响应过程中的当前活动阶段。该属性可取的值如下： 0：未初始化。尚未调用open()方法。 1：启动。已经调用open()方法，但尚未调用send()方法。 2：发送。已经调用send()方法，但尚未接收到响应。 3：接收。已经接收到部分响应数据。 4：已经接收到全部响应数据，而且已经可以在客户端使用了。 只要readyState属性的值发生变化，就会触发readystatechange事件，可以利用这个事件来检测每次变化后的readyState的值。通常我们只对readyState值为4的阶段感兴趣，因为这个时候所有的数据都已经就绪。 responseText作为响应主体被返回的文本。无论内容类型是什么，响应主体的内容都会保存在这里，如果响应包含了为响应体指定字符编码的头部，就使用该编码。否则，假定使用 Unicode UTF-8。如果 readyState 小于 3，这个属性就是一个空字符串。当 readyState 为 3，这个属性返回目前已经接收的响应部分。如果 readyState 为 4，这个属性保存了完整的响应体。 responseXML如果响应的内容类型是“text/xml”或“application/xml”，这个属性中将保存包含着响应数据的XML DOM文档。对于非XML数据而言，responseXML属性值将为null。 status响应的http状态。检查status属性可以确定响应是否已成功返回（在readyState&gt;3时才可以读取）。 http状态码200是响应成功返回的标志，此时responseText属性的内容已经就绪，而且在内容类型正确的情况下（XML类型），responseXML属性也能够访问了。 http状态码304表示请求的资源没有被修改，可以直接使用浏览器中缓存的版本，当然也意味着响应式有效的。 http状态码404表示请求错误。······ statusTexthttp状态的说明。比如在状态码为200时，statusText的值为“OK”。 XMLHttpRequest对象的方法open()在使用XHR对象时，要调用的第一个方法是open()，它接受三个参数： 要发送的请求类型，如“get”“post”等。 请求要访问的URL。 选择同步或异步的布尔值。true表执行异步操作，false表示同步。 同步：客户端发出一个请求后，需要等待服务器响应结束后，才能发出第二个请求。 异步：客户端发出一个请求后，无需等待服务器响应结束后，就能发出第二个请求。 send()send方法接收一个参数，将被写入到请求报文里面传递，即要做为请求主体发送的数据。调用send()之后，请求就会被分派到服务器。 如果不需要通过请求主体发送数据，比如请求类型是“get”时，参数是直接写到url里面，则必须传入null，因为这个参数对于某些浏览器来说是必须的。 请求类型是“post”时，请求参数需要写入到send方法里。 abort()调用这个方法后，XHR对象会停止触发事件，而且也不再允许访问与响应有关的对象属性。 http头部信息默认情况下，在发送XHR请求的同时，还会发送头部信息，虽然不同的浏览器实际发送的头部信息会有所不同，但是基本上是所有浏览器都会发送的有以下这些： Accept：浏览器能够处理的内容类型。 Accept-Charset：浏览器能够显示的字符集。 Accept-Encoding：浏览器能够处理的压缩编码。 Accept-Language：浏览器当前设置的语言。 Connection：浏览器与服务器之间连接的类型。 Cookie：当前页面设置的任何Cookie。 Host：发出请求的页面所在的域。 Referer：发出请求的页面的URI。 User-Agent:浏览器用户代理字符串。 getResponseHeader()这个方法可以设置自定义的请求头部信息，它接收两个参数： 头部字段的名称 头部字段的值 要想成功发送请求头部信息，getResponseHeader()方法必须在open()与send()之间调用。 getAllResponseHeaders()这个方法可以取得一个包含所有头部信息的长字符串。 GET请求GET是最常见的请求类型，常用于向服务器查询某些信息。使用GET请求时常用到encodeURIComponent()方法。查询字符串中每个参数的名称和值都必须使用encodeURIComponent()进行编码，才能放到URL末尾。完整的函数如下：12345function addURLParam(url,name,value)&#123; url+=(url.indexOf("?") == -1 ? "?" : "&amp;"); url+=encodeURIComponent(name)+"="+encodeURIComponent(value); return url;&#125; POST请求POST请求通常用于向服务器发送应该被保存的数据。虽然大部分情况下都能用更简单、更快的GET请求，但在以下情况中，请使用POST请求： 无法使用缓存文件（更新服务器上的文件或数据库） 向服务器发送大量数据（POST 没有数据量限制） 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠 默认情况下，服务器对POST请求和提交表单的请求并不会一视同仁，不过我们可以使用XHR来模仿表单提交。1234xhr.open("POST","example.php",true);xhr.setRequestHeader("Content-type","application/x-www-form-urlencoded"); //设置表单提交时的内容类型var form = document.getElementById("#test"); //得到表单中的数据xhr.send(serialize(form)); //表单中的数据序列化后发送给服务器 实例下面看一个完整的栗子：html代码段12&lt;input type="button" value="ajax提交" onclick="Ajax();"&gt;&lt;div id="resText"&gt;&lt;/div&gt; javascript代码段：123456789101112131415161718function Ajax() &#123; var xhr; //声明一个对象用来装入XMLHttpRequest if(window.ActiveXObject)&#123; //IE5 IE6实例化XHR对象 xhr = new ActiveXObject("Microsoft.XMLHTTP"); &#125;else if (window.XMLHttpRequest)&#123; //现代浏览器实例化XHR对象 xhr = new XMLHttpRequest(); &#125; xhr.open("get","test.php",true); //启动请求 xhr.onreadystatechange=fun; //触发回调函数 xhr.send(null); //发送请求 function fun() &#123; //定义回调函数 if(xhr.readyState == 4)&#123; if(xhr.status == 200)&#123; document.getElementById("resText").innerHTML=xhr.responseText; &#125; &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[深入理解闭包]]></title>
      <url>%2F2017%2F05%2F09%2Fclosure%2F</url>
      <content type="text"><![CDATA[写了快一周，终于把这个系列文写完了，总共六篇文章，虽然看起来只有最后一篇在讲闭包，但其实前面五篇都在为最后一篇打基础。 深入理解闭包（一）——铺垫 深入理解闭包（二）——变量对象 深入理解闭包（三）——确定this指向 深入理解闭包（四）——执行上下文栈 深入理解闭包（五）——作用域、作用域链和执行上下文 深入理解闭包（六）——闭包 另外，如果你感觉我写的还不是很清楚的话，推荐你们看这两个系列的文章：简书作者波老师写的：前端基础进阶系列 博客园王福鹏老师写的：深入理解javascript原型和闭包系列我看了好几遍他们两位的文章，从中收获颇多，我的系列文中也借鉴了许多他们的东西，由衷地感谢他们。在写这个系列文之前我对闭包也是半清不楚的，看别人文章有些复杂的例子也会弄不明白，但我写最后一篇之前，又去看了一遍那些闭包的例子，发现很多问题都迎刃而解。有一句话说的真没错，下层基础决定上层建筑。有的人js还没怎么学懂就想先学一些炫酷的框架，虽然也能解决实际问题，但我认为走不长远，地基打牢才能盖更高的楼。真正沉得住气搞基础的人才更具发展空间，这类人眼光最长远，也是我最想成为的人。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[深入理解闭包（六）——闭包]]></title>
      <url>%2F2017%2F05%2F07%2Fclosure6%2F</url>
      <content type="text"><![CDATA[终于讲到闭包了，这一路走来不容易。从前面的博文中我们知道，js的垃圾回收机制会在某个函数的执行上下文生命周期结束后将其回收，释放内存，但是闭包的存在会阻止这一过程。 概念js高程对闭包的定义是：闭包是指有权访问另一个函数作用域中的变量的函数。 创建闭包的常见方式就是在一个函数内部创建另一个函数，作为返回值或参数传递到函数外部。但是根据我的经验，只要在一个函数内部使用了关键字function，一个闭包就被创建了。 实例任何书面上的解释都不如一个实例来的有效。12345678910var a = 1;function test() &#123; var b = 2; return function () &#123; var c = 3; console.log(a+b+c); &#125;&#125;var result=test();result(); //6 按照我们之前的说法，函数外部是不能访问函数内部的变量的，代码执行到var result=test()这句时调用test函数，执行完毕后应该销毁执行上下文，其中的变量都不能再访问，但是执行result()时却仍然调用了test中的变量，这是因为我们在test函数中返回了一个匿名函数。test函数中返回的不仅仅是一个函数，还有它的执行上下文环境，将其赋值给全局变量result后，那么result其实就等同于那个返回的匿名函数，当它被调用时可以访问匿名函数作用域链中指向的变量对象（并不是把变量对象复制给了result，只是可以被引用），这个返回的匿名函数就是闭包。引用阮一峰老师对闭包的解释：闭包本质上是将函数内部和外部连接起来的桥梁。 再看一个栗子：12345678910function out() &#123; var a = 1; var inner=function () &#123; console.log(a); &#125; a++; return inner;&#125;var b = out();b(); //2 肯定会有人觉得输出的应该是1，想着a++在console.log(a)后面，这是一种常见的错觉，代码创建的位置和执行的顺序是不一样的，这点要谨记。这段代码里首先执行的是调用out函数，out函数执行代码，最后一步返回inner，要知道a++是在return之前执行的，a=2已经保存到了变量对象中，接下来调用b函数（等同于调用inner函数），输出的a自然就是2. 复杂一点的栗子：1234567891011121314151617var fun1,fun2,fun3;function test() &#123; var a=10; fun1=function () &#123;console.log(a);&#125;; fun2=function () &#123;a++;&#125;; fun3=function (x)&#123;a=x;&#125;;&#125;test();fun2();fun1(); //11fun3(5);fun1(); //5var fun4=fun1;test();fun1(); //10fun4(); //5 如果上一个栗子你已经理解，那么理解这个栗子前两次输出的11和5也不是什么难事，但后面的两个输出10和5你可能会有点疑惑。 我们第二次调用test函数时一个新的闭包被创建，它能访问到的变量也是重新创建的，跟前面的没有关系，因此再调用fun1时输出10。我们要记住这句话：如果你在一个函数内部声明了另一个函数，那么这个外部函数每次被调用都会产生一个闭包，创建崭新的执行上下文环境。 那么调用fun4怎么又输出了5呢，这是因为var fun4=fun1是在第一次调用test发生的，那么fun4可以访问的变量也是第一次调用test时创建的变量对象，即使在别的地方被调用，它的作用域链也就是可访问的变量是不变的。我们要记住这句话：一个函数可以访问的变量对象要到创建这个函数的执行环境中去找而不是调用这个函数的执行环境。 还有一个非常常见的栗子，那就是闭包对循环的影响：123456789101112var arr=[];function test()&#123; for (i= 0;i&lt;3;i=i+1)&#123; arr[i]=function()&#123; console.log(i); &#125;; &#125;&#125;test();arr[0](); // 3arr[1](); // 3arr[2](); // 3 函数运行之后会得到一个函数数组，你本想让每个函数都返回自己的索引值，比如运行arr[0]()时得到0，运行arr[1]()时得到1。但实际上，每个函数都输出3。这是因为闭包只能取得包含函数中任何变量的最后一个值，每个函数的作用域链中都保存着test函数中的变量对象，所以它们引用的是同一个变量i，而i的最后一个值是3，因此每个函数都输出3。我们可以通过创建一个自执行匿名函数来让闭包符合预期：123456789var arr=[];function test()&#123; for (i= 0;i&lt;3;i=i+1)&#123; arr[i]=(function(num)&#123; console.log(num); &#125;)(i); &#125;&#125;test(); //0,1,2 此处用到了自执行匿名函数(function(){···})()，它的写法是，在函数体外面加一对圆括号，形成一个表达式，在圆括号后面再加一个圆括号，里面可传入参数。由于函数参数是按值传递的，所以就可以把变量i的当前值赋值给匿名函数的参数num，而自执行匿名函数可以不用调用，自己执行自己，因此只要检测到参数i就会立即执行并把结果传递给arr数组。这样一来我们就能得到预期的结果了。 缺点最后一个栗子告诉我们，闭包有时也会给我们的工作带来负面效果。除此之外，还有两个缺点我们需要注意一下。 内存泄漏： 在ie9之前的版本中，如果闭包的作用域链中保存着一个html元素，那么就意味着该元素将无法销毁。 占用内存：由于闭包会携带包含它的函数的作用域，因此会比其他函数占用更多的内存。过度使用闭包可能会导致内存占用过多，所以我们最好只在绝对必要时再考虑使用闭包。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[深入理解闭包（五）——作用域、作用域链和执行上下文]]></title>
      <url>%2F2017%2F05%2F07%2Fclosure5%2F</url>
      <content type="text"><![CDATA[作用域，作用域链，执行上下文三者之间有着密切的关系，相信有一部分人对这三者只是有一种模糊的概念，今天我们就来理一理，首先我们要回顾一张图片，由这张图，你可以清楚地看到这三者分别是在什么时候创建的，其中又有什么基本的联系。 作用域作用域是在代码编译阶段确定的，一旦代码写好，它的作用域就确定了。js中只有两种作用域，即全局作用域和局部作用域。 全局作用域如果一个对象在代码的任何一个地方都可以被访问到，那么这个对象所在的作用域是全局作用域。 最外层函数和在最外层函数外面定义的变量。 所有末定义直接赋值的变量将被自动添加到全局作用域（但是严格模式下，初始化未经声明的变量会导致错误）。 所有window对象的内置属性，例如window.name、window.location、window.top等等都是全局变量，并且所有属于全局作用域的变量都是window对象的属性。 局部作用域js中的局部作用域是按照函数划分的，因此也称函数作用域，其他一些语言是按照花括号{}划分的，称为块级作用域，区别如下： 在Java、C或C++中，花括号{}内封闭的代码块有自己的作用域，在{}外部无法访问{}内部的变量，这个作用域就称为块级作用域。 在javascript中不存在块级作用域，而是把每个函数作为一个作用域，在函数外部无法访问函数内部的变量。 更多关于作用域的问题参考这篇文章：理解javascript作用域 执行上下文执行上下文就是为代码执行做的准备工作。主要分为两类： 全局执行上下文：代码刚开始运行就会创建的执行上下文。 函数执行上下文：函数被调用时创建的执行上下文。 执行上下文前面两篇文章已经讲得非常透彻了，这里也就不再多说了。 更多关于执行上下文的问题参考这两篇文章：变量对象 和执行上下文栈 。 作用域链作用域链本质上是一个指向当前环境与上层环境的一系列变量对象的指针列表（它只引用但不实际包含变量对象），作用域链保证了当前执行环境对符合访问权限的变量和函数的有序访问。举个栗子：12345678910var a = 1; function out() &#123; var b = 2; function inner() &#123; var c = 3; console.log(a+b+c); &#125; inner(); &#125;out(); 首先，代码开始运行时就创建了全局上下文环境，接着运行到out()时创建out函数的执行上下文，最后运行到inner()时创建inner函数的执行上下文，这三个执行上下文中的变量对象分别是：其中，由于函数调用时都没有传入参数，所以arguments都没有值，reference表示该函数的地址引用。 全局的作用域链：由于它只含全局作用域，没有上级，因此它的作用域链只指向本身的全局变量对象（因为只有一个，甚至可以理解为全局环境不存在作用域链）。查找标识符时只能从本身的全局变量对象中查找。 函数out的作用域链：可以引用函数out本身的变量对象以及全局的变量对象。查找标识符时，先在函数out变量对象中寻找，找不到的话再去上一级全局变量对象查找。 函数inner的作用域链：可以引用函数inner本身的变量对象和上一级out函数的变量对象以及全局的变量对象。查找标识符时依次从inner，out，全局变量对象中查找。 更多关于作用域链的问题参考这篇文章：理解javascript作用域]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[深入理解闭包（四）——执行上下文栈]]></title>
      <url>%2F2017%2F05%2F07%2Fclosure4%2F</url>
      <content type="text"><![CDATA[执行上下文可以理解为当前代码的执行环境，JavaScript中的运行环境大概包括三种情况： 全局环境：JavaScript代码运行起来会首先进入该环境 函数环境：当函数被调用执行时，会进入当前函数中执行代码 eval 在代码开始执行时，首先会产生一个全局执行上下文环境，调用函数时，会产生函数执行上下文环境，函数调用完成后，它的执行上下文环境以及其中的数据都会被销毁，重新回到全局执行环境，网页关闭后全局执行环境也会销毁。其实这是一个压栈出栈的过程，全局上下文环境永远在栈底，而当前正在执行的函数上下文在栈顶。我们就用一个简单的栗子来体会执行上下文出栈入栈的过程：12345678910var a = 1; //1.进入全局上下文环境function out() &#123; var b = 2; function inner() &#123; var c = 3; console.log(a+b+c); &#125; inner(); //3.进入inner函数上下文环境&#125;out(); //2.进入out函数上下文环境 第一步：当代码开始执行时就创建全局执行上下文环境，全局上下文入栈。第二步：全局上下文入栈后，其中的代码开始执行，进行赋值、函数调用等操作，执行到out()时，激活函数out创建自己的执行上下文环境，out函数上下文入栈。第三步：out函数上下文入栈后，其中的代码开始执行，进行赋值、函数调用等操作，执行到inner()时，激活函数inner创建自己的执行上下文环境，inner函数上下文入栈。第四步：inner函数上下文入栈后，其中的代码开始执行，进行赋值、函数调用、打印等操作，由于里面没有可以生成其他执行上下文的需要，所有代码执行完毕后，inner函数上下文出栈。第五步：inner函数上下文出栈，又回到了out函数执行上下文环境，接着执行out函数中后面剩下的代码，由于后面没有可以生成其他执行上下文的需要，所有代码执行完毕后，out函数上下文出栈。第六步：out函数上下文出栈后，又回到了全局执行上下文环境，直到浏览器窗口关闭，全局上下文出栈。 总结：我们观察一下入栈出栈的全部过程：我们可以得到一些结论： 全局上下文在代码开始执行时就创建，只有唯一的一个，永远在栈底，浏览器窗口关闭时出栈。 函数被调用的时候创建上下文环境。 只有栈顶的上下文处于活动状态，执行其中的代码。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[深入理解闭包（三）——确定this指向]]></title>
      <url>%2F2017%2F05%2F07%2Fclosure3%2F</url>
      <content type="text"><![CDATA[我们在前面说过，在执行上下文创建过程中做了三件事：创建变量对象，生成作用域链，确定this指向。今天我们就来探讨一下this指向的问题。首先先回顾一下我们执行上下文的生命周期图：执行上下文是函数被调用时创建的，创建过程包括确定this指向，所以this的指向是在函数被调用时确定的。 我们知道，this对象是在运行时基于函数的执行环境绑定的：在全局环境中，this指向window，当函数被作为某个对象的方法调用时，this指向那个对象。不过实际情况中往往没有那么好判断，今天我们就来梳理一下。 全局对象中的this在全局环境下，this永远指向window。1console.log(this); //window 函数中的thisthis指向调用这个函数的对象。123456var a = 10;function test() &#123; var a = 20; console.log(this.a);&#125;test(); //10 由于函数test是被全局对象（window）调用的，因此函数内部的this指向window。1234567891011var a = 20;var obj = &#123; a: 10, b:this.a, fn: function () &#123; return this.a; &#125;&#125;console.log(obj.fn()); //10console.log(obj.b); //20 由于函数fn是被对象obj调用的,因此函数fn内部的this指向对象obj。另外，由于obj不是个函数，不适合上面的规则，我们要单独讨论，如果obj对象在全局创建，那么obj里面的this指向window。 构造函数构造函数和其他函数的唯一区别，就是他们的调用方式不同。任何函数，只要通过new操作符来调用，那它就可以作为构造函数，调用时经历以下四个步骤： 创建一个新对象； 将构造函数的作用域赋给新对象（因此this就指向了这个新对象）； 执行构造函数中的代码（为这个新对象添加属性）； 返回新对象。 123456function Test() &#123; this.a = 1; console.log(this.a); //1&#125;var fun = new Test();console.log(fun.a); //1 创建新对象new Test()后，this指向这个新对象，然后为这个新对象添加属性a = 1，再执行console.log(this.a)，此时输出的就是刚添加的a值。返回这个新对象传递给了实例对象fun，此时this指向了实例fun，因此fun.a也为1。 函数用call或apply调用我们可以利用call或apply手动设置this的指向，这两个方法的第一个参数都是this将要指向的对象，后面的参数，都是向将要执行的函数传递参数。其中call以一个一个的形式传递，apply以数组的形式传递，这是他们唯一的不同。123456789var obj = &#123; num: 10&#125;function test(a, b) &#123; console.log(this.num + a + b);&#125;test(20,30); //NaNtest.call(obj, 20, 30); // 60test.apply(obj, [20, 30]); // 60 这个例子很容易理解，本来调用test函数this指向全局对象，是无法访问到obj对象中的num的，但是利用call和apply方法将this指向了obj对象，所以可以顺利输出。 以上就是我目前知道的关于this指向的几种情况，以后可能会再补充。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[深入理解闭包（二）——变量对象]]></title>
      <url>%2F2017%2F05%2F05%2Fclosure2%2F</url>
      <content type="text"><![CDATA[执行一个函数之前，JavaScript引擎会进行准备工作，这个准备工作指的就是执行上下文，也叫执行上下文环境，也叫执行环境。下面是一个执行上下文的周期图，其中变量对象（Variable Object）是重点之一，只有理解了它，我们才能知道一段代码的执行过程中先做什么，后做什么，我们今天就探讨一下变量对象在执行上下文生命周期中都经历了怎样的变化： 创建阶段 建立arguments对象(参数对象，当某个函数接收参数的时候，会将参数封装成arguments对象)。 检查当前上下文的函数声明，也就是使用function声明的函数。在变量对象中以函数名建立一个属性，属性值为指向该函数所在的内存地址的引用。如果函数名的属性已存在，那么该属性将会被新的引用所覆盖。 检查当前上下文的变量声明，也就是使用var声明的变量，对于每一个变量声明，变量对象会以变量名建立一个属性，属性值为undefined。函数的声明比变量优先级要高，并且定义过程不会被变量覆盖，除非是赋值。 执行阶段执行阶段没有什么难以理解的，有两点需要知道一下： 代码执行时按照顺序，该赋值时赋值，该调用时调用，这个一看后面的栗子就明白了。 变量对象转变为了活动对象（Active Object），其实这俩是一个东西，只是所处的时期不同罢了。 栗子们栗子1：1console.log(a); //a is not defined 上面代码执行环境中根本没有定义变量a12console.log(a); //undefinedvar a = 10; 虽然同样没有打印a的值，但是跟之前不同的是，这里执行环境中查找到了变量a，但是在打印时它还没有进行赋值，因为查找变量a是在执行上下文创建阶段完成的，并定义为undefined，然后才进入执行阶段，但是打印a的语句在前面，赋值语句在后面，所以打印出来的是a的初始值undefined，这也就体现了前面说的执行阶段是按照顺序执行相关赋值、打印、函数调用等代码。我们可以把上面代码等效成下面的形式：123var a;console.log(a);a = 10; 栗子2：12345console.log(test); //function test（）&#123; return 1;&#125;console.log(test()); //1 test是函数，test()是函数调用之后返回的值function test() &#123; return 1;&#125; 上面代码在创建阶段检查到的是函数声明,因此可以顺利打印函数。12345console.log(test); //undefinedconsole.log(test()); //test is not a functionvar test = function () &#123; return 1;&#125; 这段代码也是要打印函数，但是却得到了截然不同的效果，因为这里的test其实是一个变量声明，只不过给它赋值的是一个函数，但是在创建阶段它的初始值仍是undefined。 栗子3：12345678910111213141516171819202122function test(x,y) &#123; console.log(arguments); //&#123; '0': 1, '1': 2 &#125; console.log(a); //undefined console.log(b); //function func()&#123; return 2; &#125; console.log(b()); //2 console.log(c); //unundefined var a = 10; console.log(a); //10 function b() &#123; return 1; &#125; function b() &#123; return 2; &#125; var b; var c=function () &#123; return 3; &#125; console.log(c); //function func()&#123; return 2; &#125; console.log(c()); //3&#125;test(1,2); 分析： 检查到函数调用时传入了参数（1，2），以参数为属性值封装成arguments对象{ ‘0’: 1, ‘1’: 2 }。 检查函数声明，先检查到第一个b函数，便以b为属性名，b函数的内存地址引用为属性值建立一个属性。但紧接着又检查到一个b函数，属性值将会被后面的b函数覆盖，因此打印b函数时得到的是后面声明的b函数。 检查变量声明，得到变量a,b,c,由于函数b的存在，b属性已经被创建了，并且这里的变量b并没有赋值，因此它不会覆盖属性b的值，而是跳过。不过另外的变量a和c都顺利创建属性a和c，属性值为undefined。 按顺序执行代码，第一次打印a时还没有经过赋值，因此输出undefined，第二次打印a时已经赋值，因此输出10，其他同理，不再解释。 如果按照执行顺序把栗子3代码做个等效的话，是下面这样的：1234567891011121314151617181920function test(x,y) &#123; function b() &#123; return 2; &#125; var a； var c； console.log(arguments); console.log(a); console.log(b); console.log(b()); console.log(c); a = 10; console.log(a); c=function () &#123; return 3; &#125; console.log(c); console.log(c()); &#125;test(1,2); 结语现在我猜你对于一段代码的执行过程应该已经了解得差不多了，你不要觉得这跟闭包看起来没有关系就忽略这里的知识点，其实你对基础的东西理解透彻，对后面难点的理解是潜移默化的，不仅仅是闭包，很多难点在夯实的基础面前都是赤身裸体的，很容易就能看得一清二楚。今天关于变量对象就说到这里，下一次我们会进一步探查执行上下文的奥秘。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[深入理解闭包（一）——铺垫]]></title>
      <url>%2F2017%2F05%2F05%2Fclosure1%2F</url>
      <content type="text"><![CDATA[前两天写了一篇关于作用域和作用域链的文章，还自以为理解透了，这两天一直在琢磨闭包，才发现我之前对作用域和作用域链的理解简直不忍直视，甚至那个时候我还以为执行上下文跟作用域是同一个东西，哇现在真想死一死。看了那么多讲闭包的文章之后我也得出一个经验，一篇文章是讲不清闭包的，因为你需要理解的不仅仅是闭包，还有前面需要铺垫的很多知识，所以我打算写一个系列文，今天我就先回忆一些基础知识。 堆与栈堆与栈是两种数据结构，栈在javascript的执行上下文中有重要体现，因此我们有必要去弄懂它。 堆堆的存取方式比较灵活，程序员为数据分配空间进行存储，引用数据时只需要知道数据存在了那个地址就可以使用，就像是我们去图书馆找一本书，只需要知道这本书的编号就能知道书的位置，找到对应的书架找到想要的书。 栈栈的存取方式遵循先进后出原则。如上图：存储数据时，1最先入栈，4最后入栈；使用数据时，4最先出栈，1最后出栈。大家都打过羽毛球吧，装羽毛球的长筒就类似于这个栈，桶口就一个，我们每次只能拿出最上面的那个球，要想拿出下面的球就必须把它上面的都拿出来。 数据的基本类型和引用类型基本数据类型基本类型值指的是简单数据段,JavaScript中有5中基本数据类型，分别是Undefined、Null、Boolean、Number、String。基本数据类型是按值访问,如果从一个变量向另一个变量复制基本类型的值，会在变量对象上创建一个新值，把该值复制到为新变量分配的位置上。举个栗子： 12var num1 = 5;var num2 = num1; num1中保存的值是5，又定义一个变量num2，并用num1的值来初始化它，那么num1的5就复制给了num2，但这两个5是互相独立的，谁都不影响谁，即使你改变了其中一个的值，另外一个也不会受到影响。 引用数据类型引用类型值指的是那些可能由多个值构成的对象，如数组。引用数据类型是按引用访问的，当一个变量向另一个变量复制引用类型值的时候，复制的不是一个值而是一个指向这个值的指针，复制操作结束后，两个变量实际上将引用同一个对象，因此改变其中一变量，另一个也随之改变。举个栗子： 1234var obj1 = new Object();var obj2 = obj1;obj1.name = "Nicholas";alert(obj2.name); //"Nicholas" 首先，变量obj1保存了一个对象的新实例，然后这个值被复制到了obj2中，此时它们都指向同一个对象，因此当我们给obj1添加name属性后，可以通过obj2来访问这个属性，如果你还不理解，那么你看完下图就会了然了。 下面我们看两个小测试来检测一下自己对上面内容的理解 1234567891011var a = 10;var b = a;b = 30;console.log(a); //10``` ```jsvar m = &#123; a: 10, b: 20 &#125;var n = m;n.a = 30;console.log(m.a); //30 垃圾回收机制函数中局部变量经历一个生命周期： 当我们定义一个变量时，会为它分配一个内存空间用来储存变量的值 当我们读取或使用这个变量时，会使用它的内存空间 使用完毕时会释放内存空间 上面生命周期的最后一步，其实就是垃圾回收。JavaScript有自动垃圾收集机制，就是找出那些不再继续使用的值，然后释放其占用的内存，那么怎么判断什么值不再使用呢，一般来说，当一个函数执行完毕，那么这个局部作用域内的变量就没有存在的必要了，它的内存空间就会释放，但是有一种情况可以阻止这一进程，那就是——闭包。 javascript代码执行过程这个流程图是javascript代码执行要经历的一个完整过程，其中我标出了作用域，执行上下文，作用域链，即使你现在还不明白这个流程图的每个部分都是做什么的，但是你现在至少应该明白这三者是完全不一样的概念。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[理解javascript作用域]]></title>
      <url>%2F2017%2F05%2F02%2Fjs-scopeChain%2F</url>
      <content type="text"><![CDATA[任何程序设计语言都有作用域的概念，简单的说，作用域就是变量或函数的作用范围。在JavaScript中，变量的作用域有全局作用域和局部作用域两种，并且局部作用域是按照函数划分的，而不是块级作用域，下面我们就来详细区分一下这些作用域。 函数作用域和块级作用域 在Java、C或C++中，花括号{}内封闭的代码块有自己的作用域，在{}外部无法访问{}内部的变量，这个作用域就称为块级作用域。 在javascript中不存在块级作用域，而是把每个函数作为一个作用域，在函数外部无法访问函数内部的变量。 为了解决块级作用域，ES6引入了新的关键字let，用let替代var可以申明一个块级作用域的变量。 举个栗子： 123456function test() &#123; if (true)&#123; var color="blue"; &#125; alert(color);&#125; 在Java、C或C++中，if语句内部是一个块作用域，color变量在if语句中声明，并在if语句执行完毕后被销毁，即就是说if语句外部不可访问内部的变量，因此本例alert(color)将出现报错undefined。 在javascript中，test()函数内部是一个函数作用域，由于没有块作用域，if语句中的变量声明也属于当前的函数作用域，alert命令在该作用域内部，可以访问color变量，因此本例alert(color)将输出“blue”。 再举个栗子： 123456function test() &#123; for(var i=0; i&lt;10;i++)&#123; doSomething(i); &#125; alert(i);&#125; 在Java、C或C++中，for语句内部是一个块作用域，其初始化变量的表达式所定义的变量（本例中是变量i），只会存在于循环的环境之中（即该块作用域），因此本例alert（i）将出现报错undefined。 在javascript中，test()函数内部是一个函数作用域，由于没有块作用域，由for语句创建的变量i即使在for循环执行结束后也依旧会存在于循环外部的函数作用域中，因此本例alert（i）将输出10。 如果本例中用let替代var定义变量i，那么alert（i）也会报错，因为用let替代var可以申明一个块级作用域的变量。 全局作用域在代码中任何地方都能访问到的对象拥有全局作用域，一般来说以下3种变量对象拥有全局作用域： 最外层函数和在最外层函数外面定义的变量。 所有末定义直接赋值的变量将被自动添加到全局作用域（但是严格模式下，初始化未经声明的变量会导致错误）。 所有window对象的内置属性，例如window.name、window.location、window.top等等都是全局变量，并且所有属于全局作用域的变量都是window对象的属性。 举个栗子： 1234567891011121314var a=1;function test() &#123; var b =2; c=3; alert("执行了test1函数");&#125;alert(a); //输出1，因为变量a是最外层函数外面定义的变量alert(b); //报错undefinedtest(); //弹出“执行了test1函数”，因为test()是最外层函数alert(c); //输出3，因为末定义直接赋值的变量将被自动添加到全局作用域alert(window.location); //弹出了文档当前地址和相关信息，因为window的内置属性是全局变量alert(window.a); //输出1，因为全局作用域变量a也是window对象的属性 上例需要注意一点，如果在调用test()之前alert(c)会报错，因为你如果没有调用过这个函数，浏览器根本不会读取到函数里面的这个变量c。 局部作用域只在函数内部才能访问到的对象拥有局部作用域。举个栗子：1234567function test() &#123; var b =2; alert(b);&#125;alert(b); //报错undefined，因为这个alert命令位于函数外部，访问不到函数内部的变量btest(); //2，因为调用这个函数时，执行了函数内部的alert命令，可以访问到变量b 作用域链前面的例子都很好理解，因为我定义的变量都是不同的，互不干扰，但是如果局部变量跟全局变量重名了就会比较难以判断。举个栗子： 12345678var a =1;function test()&#123; alert(a); var a = 2; alert(a);&#125;test(); //undefined,2 估计很多人都会以为在调用test()函数时会弹出1，2，但事实上弹出了undefined,2，要理解其中的缘由，那必须理解作用域链。 概念：作用域链的作用就是保证对作用域内有权访问的变量和函数的有序访问（这句话贼绕）。通俗地说，作用域链可以被看作一种有秩序的路径,在变量解析过程中首先查找当前局部的作用域，然后查找上层作用域，内到外地查找，直到到找到最近定义的的该变量。 那么现在再去理解一下上面的例子，第一次alert(a)的时候，先在当前作用域中也就是函数test()内部查找到变量a已经被定义，但是此时并没有赋值，所以输出undefined；第二次alert(a)的时候，当前局部作用域中查找到已经赋值的变量a,所以输出2。 再举个栗子： 1234567891011var a =1;function test()&#123; var b = 2; alert(a); alert(b); alert(c); function test2() &#123; var c = 3; &#125;&#125;test(); //1,2,undefined alert(a)：当前局部作用域test()内部查找变量a没有找到，上层全局作用域查找到a =1，输出1。 alert(b)：当前局部作用域test()内部查找变量b得到b=2，输出2。 alert(c)：当前局部作用域test()内部查找变量c没有找到，上层全局作用域也没有找到，输出undefined。 另外，从作用域链的结构可以看出，被访问的对象所在的位置越深，读写速度就会越慢。因为全局变量总是存在于作用域链的最末端，因此查找全局变量是最慢的。所以，在编写代码的时候应尽量少使用全局变量，多使用局部变量。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[浮动与清除浮动]]></title>
      <url>%2F2017%2F04%2F29%2Fcss-float%2F</url>
      <content type="text"><![CDATA[浮动浮动的概念浮动元素会脱离文档流并向左/向右浮动，直到碰到父元素或者另一个浮动元素。 float：left | right | none | inherit 举个栗子: 当框 1 向右浮动时，它脱离文档流并且向右移动，直到它的右边缘碰到包含框的右边缘。 当框 1 向左浮动时，它脱离文档流并且向左移动，直到它的左边缘碰到包含框的左边缘。因为它不再处于文档流中，所以它不占据空间，框2填补了它的位置且被覆盖，使框 2 从视图中消失。 如果把所有三个框都向左浮动，那么框 1 向左浮动直到碰到包含框，另外两个框向左浮动直到碰到前一个浮动框。 浮动的特性 脱离文档：元素设置为浮动后脱离文档流，并不占据空间，而此浮动元素在文档流空出的位置，由后续的非浮动元素填充，块级元素直接填充上去，内联元素则有空隙就插入。 浮动可以内联排列：浮动会向左/向右浮动，直到碰到另一个浮动元素为止，这是浮动可以内联排列的特征。也就是说，浮动可以设置宽高，并且能够一行多个，类似于inline-block属性的效果。 父元素高度坍塌：浮动元素脱离了文档流，并不占据文档流的位置，自然父元素也就不能被撑开，所以没了高度。 清除浮动清除浮动的概念在非IE浏览器（如Firefox）下，当容器的高度为auto，且容器的内容中有浮动（float为left或right）的元素，在这种情况下，容器的高度不能自动伸长以适应内容的高度，使得内容溢出到容器外面而影响（甚至破坏）布局的现象。这个现象叫浮动溢出，为了防止这个现象的出现而进行的CSS处理，就叫CSS清除浮动。举个栗子：html： &lt;div class=&quot;out&quot;&gt; &lt;div class=&quot;box&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;3&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;4&lt;/div&gt; &lt;/div&gt; css： .out{ width: 300px; border: 2px solid #55a532; } .box{ background-color: #f7c942; height: 50px; width: 50px; } 上面是未设置浮动时的效果，下面我们给容器里面的子元素设置向左浮动： .box{ background-color: #f7c942; height: 50px; width: 50px; float: left; } 我们可以看到，子元素设置浮动后父元素只剩下了重合后的边框，这是因为元素脱离了文档流，不能撑开父元素，所以父元素的高度坍塌了，而子元素也溢出到容器外面，这就是浮动溢出现象。要消除这个现象就得清除浮动。 清除浮动的方法方法一：添加带clear属性的空元素clear 属性规定元素的哪一侧不允许其他浮动元素。 clear ：left | right | both | none | inherit 我们给浮动元素后面添加一个空元素 &lt;div class=&quot;out&quot;&gt; &lt;div class=&quot;box&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;3&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;4&lt;/div&gt; &lt;div class=&quot;none&quot;&gt;&lt;/div&gt; &lt;/div&gt; 给空元素设置clear属性 .none{ clear: both; } 原理是设置clear后，父容器必须考虑非浮动子元素的位置，而后者肯定出现在浮动元素下方，所以显示出来，父容器就把所有子元素都包括进去了 另外，如果浮动元素后面存在着不浮动的块元素，那么直接给后者添加clear: both属性即可，不必添加空元素多此一举。 方法二：after伪元素after伪元素可以在父容器的尾部自动创建一个子元素，也就是说我们不必修改html，可以直接通过css来添加新元素，达到跟上一种方法同样的效果。 .out:after { content: &quot;&quot;; display: block; height: 0; clear: both; } .out{ zoom: 1; } content属性，表示伪元素的内容,设置:before和:after时必须设置其content属性，否则伪元素就不起作用，本例content: “”表示给父元素结尾放了一个空白字符。 after添加的内容默认是inline元素，但是行内元素会找空隙插入浮动元素，依然撑不起父容器高度，所以我们需要把插入的元素设置成块元素block。 height: 0是让这个这个空白字符不显示出来。 由于IE6不支持after，我们添加一条IE6的独有命令”zoom:1”就行了，这条命令的作用是触发父元素的”hasLayout”属性（即令hasLayout的值为true），让父元素拥有自己的布局，IE6会读取这条命令，其他浏览器则会直接忽略它。 （haslayout为true时，它就不得不去渲染它自己，因此元素不得不扩展去包含它的流出的内容，例如浮动，而zoom:1是最常用，最安全，成本最少的触发hasLayout的方式。） 方法三：父元素设置overflow: auto/hidden给浮动元素的父元素添加overflow: auto或者overflow: hidden属性之后会自动计算超出的大小，所以父容器会自动撑开自己把所有的子元素放进去，浮动元素也回到了容器层，达到了清理浮动的效果。但是如果子元素的大小超过父容器的大小，就会出现显示问题,不推荐使用。 .out{ overflow: auto; zoom: 1; /*处理ie6兼容问题*/ } 方法四：父元素设置浮动给浮动元素的容器也添加上浮动属性即可清除内部浮动，但是这样会使其整体浮动，影响布局，也容易出现新的浮动问题，不推荐使用。 .out{ float: left; } 方法五：父元素设置display:table将父容器变成表格可以清除浮动，但是非表格内容用table来装，不符合标签语义化要求，还可能会出现未知问题，故不推荐使用。 .out{ display: table; } 小结据说浮动诞生的时候主要是用来实现文字围绕图片的效果，但是后来越来越多的人用它来布局，虽说存在的即合理的，用浮动布局确实有它的道理和好处，但是对我来说，我还是不太喜欢用浮动来布局，绝对定位也是一样，他们总给我一种不安全感，让我觉得我的页面不是一个整体，随时都有可能崩坏。总之打好基础才是做出一个稳定页面的前提，道阻且长。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[flex布局语法篇]]></title>
      <url>%2F2017%2F04%2F26%2Fflex%2F</url>
      <content type="text"><![CDATA[之前写过一篇关于实现元素居中的博文，我们发现每种布局要求都可以运用flex布局实现。其实令元素居中只是flex强大的其中一个体现，可以说不管是什么布局，flex往往都可以几行命令搞定。今天我就来总结一下关于flex语法方面的内容。 基本概念Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。flex是一个布局模块，而不是一个简单的属性，它可以实现各种各样的布局，可以在任何流动的方向上(包括上下左右)都能进行良好的布局，也以弹性的在任意的容器中伸缩大小，可以方便让元素对齐容器的左、右、中间等等。任何元素都可以指定flex布局，但是要注意设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。 相关术语 弹性容器(Flex container)：包含着弹性项目的父元素。通过设置 display 属性的值为 flex 或 inline-flex 来定义弹性容器。 弹性项目(Flex item)：弹性容器的每个子元素都称为弹性项目。弹性容器直接包含的文本将被包覆成匿名弹性单元。 轴(Axis)：每个弹性框布局包含两个轴。弹性项目沿其依次排列的那根轴称为主轴(main axis)。垂直于主轴的那根轴称为侧轴(cross axis)。 方向(Direction)：弹性容器的主轴起点(main start)/主轴终点(main end)和侧轴起点(cross start)/侧轴终点(cross end)描述了弹性项目排布的起点与终点。 容器的属性flex-direction flex-direction定义了伸缩容器的主轴，决定了伸缩项目放置在伸缩容器的方向 。 flex-direction: row | row-reverse | column | column-reverse row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 flex-wrapflex-wrap定义了伸缩容器的侧轴，侧轴的方向决定了新行堆放的方向（即是否换行）。 flex-wrap: nowrap | wrap | wrap-reverse nowrap(默认值)：不换行。 wrap：换行，第一行在上方。 wrap-reverse：换行，第一行在下方。 flex-flowflex-flow是flex-direction和flex-wrap属性的缩写；同时定义了伸缩容器的主轴和侧轴，其默认值为row nowrap。 flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt; 举个栗子： .container-1{ flex-flow: row-reverse wrap-reverse; } .container-2{ flex-flow: column wrap; } justify-contentjustify-content定义了项目在主轴上的对齐方式。 justify-content: flex-start | flex-end | center | space-between | space-around flex-start(默认值)：向起始位置靠齐。 flex-end：向结束位置靠齐。 center：居中。 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 align-itemsalign-items定义项目在侧轴上如何对齐， align-items: flex-start | flex-end | center | baseline | stretch stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 flex-start：侧轴的起点对齐。 flex-end：侧轴的终点对齐。 center：侧轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。下面例图基于主轴方向为flex-direction：row，水平对齐方式为justify-content: space-between，依次改变侧轴对齐方式 align-items： align-contentalign-content定义了多根轴线（多行排列）的对齐方式。如果项目只有一根轴线（单行），该属性不起作用，即必须设置换行flex-wrap: wrap。这个属性与上面的align-items相似，把一根轴线（行）看作是一个项目就好理解了。 align-content: flex-start | flex-end | center | space-between | space-around | stretch stretch（默认值）：轴线占满整个侧轴。 flex-start：与侧轴的起点对齐。 flex-end：与侧轴的终点对齐。 center：与侧轴的中点对齐。 space-between：与侧轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 项目的属性orderorder属性定义项目的排列顺序。数值越小，排列越靠前，默认值为0，伸缩项目是按照文档流出现先后顺序排列。可以取负值。 order: &lt;integer&gt; 举个栗子：下面让第一个元素排在最后，最后一个元素排在第一个 .container{ display: flex; } .container .item-6{ order: -1; } .container .item-1{ order: 1; } flex-grow flex-grow定义项目的扩展比例，项目根据容器的剩余空间按比例扩展。默认值为0，即如果存在剩余空间，也不扩展。如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。负值对该属性无效。 flex-grow: &lt;number&gt; 举个栗子： .container-1,.container-2,.container-3{ margin-bottom: 30px; display: flex; justify-content: space-between; } .container-2 .item-1,.container-2 .item-2,.container-2 .item-3{ flex-grow: 1; } .container-3 .item-2{ flex-grow: 2; } .container-3 .item-1,.container-3 .item-3{ flex-grow: 1; } flex-shrinkflex-shrink定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。负值对该属性无效。 flex-shrink: &lt;number&gt; 举个栗子： .container-1,.container-2,.container-3{ display: flex; margin-bottom: 30px; justify-content: space-between; } .container-2 .item-1,.container-2 .item-2,.container-2 .item-3{ flex-shrink: 0; } .container-3 .item-1{ flex-shrink: 0; } .container-3 .item-2{ flex-shrink: 1; } .container-3 .item-3{ flex-shrink: 2; } align-selfalign-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 align-self: auto | flex-start | flex-end | center | baseline | stretc 举个栗子： .container{ display: flex; align-items: flex-start; } .container .item-4{ align-self: flex-end; } flex-basisflex-basis定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。它可以设为跟width或height属性一样的值，则项目将占据固定空间。 flex-basis: &lt;length&gt; | auto flexflex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。 flex: none | [ &lt;flex-grow&gt; &lt;flex-shrink&gt; || &lt;flex-basis&gt; ] 小结今天的flex语法就说这么多吧，写这篇文章参考了阮一峰老师的flex语法教程，他写的真的特别好，清晰有条理，也通俗易懂，我参照他的教程加入自己的理解，写出这篇博文，文章里所有的例子图片都是我自己敲着代码做出来的，也算是收获巨大，后面有时间的话还会再写一篇关于flex实例的文章，学以致用。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[详解绝对定位和相对定位]]></title>
      <url>%2F2017%2F04%2F25%2Fcss-position%2F</url>
      <content type="text"><![CDATA[上一篇博文中对元素的居中方式进行了总结，其中很多方法中都用到了相对定位和绝对定位，关于这两种定位方式确实是CSS中的一大难点，如果不能深入了解这两种定位方式，进行页面排版时就容易出现混乱，所以今天我对position的所有属性取值进行一个总结，重点剖析绝对定位和相对定位之间的联系和区别。 position的不同取值 不管是哪种定位，都必须有一个参照物，理清参照物我们就对这些定位方式了解了一半。 static，默认值。位置设置为static的元素，它始终会处于页面流给予的位置（static 元素会忽略任何 top、bottom、left、right和z-index 声明）。 inherit，规定应该从父元素继承 position 属性的值。但是任何的版本的 Internet Explorer （包括 IE8）都不支持属性值 “inherit”。 fixed，生成绝对定位的元素，可定位于相对于浏览器窗口的指定坐标。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。不论窗口滚动与否，元素都会留在那个位置。 absolute，生成绝对定位的元素，相对于距该元素最近的已定位（position不为static）的祖先元素进行定位。此元素的位置可通过 “left”、”top”、”right” 以及 “bottom” 属性来规定。 relative，生成相对定位的元素，相对于该元素在文档中的初始位置进行定位。通过 “left”、”top”、”right” 以及 “bottom” 属性来设置此元素相对于自身位置的偏移。 相对定位relative 相对定位的参照物是它本身 每一个元素都可以看作一个盒子，文档流就是由这些盒子堆砌而成，而每个盒子都在这个文档流中占据了一个位置，如果我们把这个盒子设置成相对定位，那么就可以拿起这个盒子相对于它原来所占据的位置向别的地方移动，如设置left:50px就是相对于盒子原来位置向右移动了50个像素，我们用具体的例子来说明。下面是一个所有元素都没有设置过任何定位方式的原始页面布局。 我们把box-2设置成相对定位并向右移动60像素，向下移动120像素。 .box-2{ background-color: #00A5FF; position: relative; left: 60px; top:120px; } 得到下面的效果 从上图我们可以发现box-2相对于它原来的位置向下且向右移动了，并且原来的位置留下了一片空白，但是其他的元素并没有占据它，说明元素设置相对定位后，可以相对于其在普通流中的位置偏移，原本所占的空间仍保留。 同时我们从图上可以看出，box-2移动之后覆盖了其他的元素，这说明当元素被设置相对定位后，将激活z-index属性，其层叠级别高于原本的文档流。此时如果给box-5也设置 position: relative，那么box-5又会覆盖box-2。 绝对定位absolute 绝对定位的参照物是相对于该元素最近的已定位的祖先元素，如果没有一个祖先元素设置定位，那么参照物是body。 绝对定位与相对定位的一大不同之处就是，当我们把一个元素设置成绝对定位，那么这个元素将会脱离文档流，漂浮在文档流上方，并且后面的元素将会填充它原来的位置。绝对定位元素根据它的参照物移动自己的位置，而参照物则需要根据它祖先元素的定位设置来确定。我们就用实例说明绝对定位的特点和需要注意的地方。下面是一个所有元素都没有设置过任何定位方式的原始页面布局。 祖先元素都没有设置定位，元素相对于body转移位置。给box-2设置成position: absolute; .box-2{ background-color: #00A5FF; position: absolute; } 得到下面的效果 我们可以看到最后一个box存在的位置空了出来，这是因为box-2脱离文档流漂浮到文档上方，并且后面的元素填补了上去，说明元素设置绝对定位后脱离文档流，后面的元素将填补它的位置。 接着你可能就会发现box-3失踪了，其实它没有失踪，它是在box-2下面，就像相对定位一样，当元素被设置绝对定位后，将激活z-index属性，其层叠级别高于原本的文档流。 你可能会问了，不是说祖先元素都没有定位时，元素会相对于body来改变自己的位置吗，为什么它还是飘在原来的位置，而没有飘到body顶头呢，那么请看，我把left和top属性加上会出现什么样的结果。 .box-2{ background-color: #00A5FF; position: absolute; left: 0; top:0; } 得到下面的效果 现在可以看到它与body顶头了，因为光设置一个元素的相对定位它只会漂浮到原来位置的上空，并不会漂浮到参照物的文档流最前方，而只有设置了left、top、right、bottom这些参数的时候才能激活它相对于参照物移动的效果。 祖先元素grandpa设置定位，元素相对于grandpa转移位置。 .grandpa{ background-color: #55a532; height: 500px; width: 600px; margin: 40px; position: relative; } .box-2{ background-color: #00A5FF; position: absolute; left: 20px; top:20px; } 得到下面的效果 祖先元素father设置定位，元素相对于father转移位置。 .father{ background-color: #55a532; height: 400px; width: 500px; margin: 50px; position: relative; } .box-2{ background-color: #00A5FF; position: absolute; left: 20px; top:20px; } 得到下面的效果 父元素son以及祖先元素father、grandpa都设置定位，元素相对于son转移位置。 .grandpa,.father,.son{ position: relative; } .box-2{ background-color: #00A5FF; position: absolute; left: 20px; top:20px; } 得到下面的效果 当祖先元素不止一个设置了定位的时候，选择最近的一个作为参照物。 小结现在你应该就能明白为什么上一篇博文中那么多居中方式都要设置其父元素的position为relative了吧，其实虽然absolute要求的是祖先元素的定位方式是除static都可以，但是最好还是设置成相对定位，因为你只设置relative而不设置left、top等参数的话对元素自身和其他元素是没有影响的，但如果你设置成fixed，元素就有可能受到浏览器窗口的影响（如果有特殊需要当然可以使用），而你设置成inherit也没有什么意义，况且浏览器对它的支持性也不是很好，显然用来限制absolute的话用relative是最合适的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS各种居中实现方式]]></title>
      <url>%2F2017%2F04%2F24%2Fcss-center%2F</url>
      <content type="text"><![CDATA[很多人刚学CSS的时候可能会觉得它很简单，心想不就是一个“背”字吗，把这些样式全记下不就行了吗？其实你一段时间之后就会明白，背是远远不够的，你需要弄清每一个属性的不同值分别得到什么效果，几个属性的组合又会带来什么结果，只有由内而外地理解这些属性，才能找到最便捷的方法达到你想要的效果，理解不是背出来的，是无数次的实践和踩坑得到的。 CSS居中是每次布局都需要面对的问题，我也是踩了无数次的坑才得出一点感悟和经验，今天我就对它做个总结，我相信一个全面的总结会对以后的学习和实践带来很大的帮助。 内联元素 内联元素的特点 和其他元素都在一行上 设置高度height 无效，可以通过line-height来设置 设置margin和padding只有左右有效，上下无效 宽度就是它的文字或图片的宽度，不可改变 内联元素只能容纳文本或者其他内联元素 以下实例都是基于下面的html代码： &lt;div class=&quot;out&quot;&gt; &lt;span class=&quot;in&quot;&gt; 居中元素 &lt;/span&gt; &lt;/div&gt; 水平居中 父元素样式设置为text-align:center，里面包含的行内元素居中,如果父元素内部还存在包含文字且不定宽的块元素，那么这个块元素也会居中。 .out{ text-align: center; } 父元素样式设置为display:flex; justify-content:center，里面包含的行内元素居中。 .out{ display:flex; justify-content:center } 垂直居中 单行文本：可将其父元素的高度和行高设置为相等的值 height = line-height .out{ height: 100px; line-height: 100px; } 多行文本：用一个span标签将所有的文字封装起来，再用一个容器包裹span，设置属性display: table-cell;vertical-align: middle。这种方法同样适用于使图片居中。 .out{ display: table-cell; vertical-align: middle; } 父元素样式设置为display:flex; align-items: center，里面包含的行内元素居中。 .out{ display:flex; align-items: center; } 块级元素 块级元素的特点 总是在新行上开始，占据一整行 高度，行高以及外边距和内边距都可控制 宽度缺省是它的容器的100%，除非设定一个宽度 它可以容纳内联元素和其他块元素 以下实例都基于下面的html代码： &lt;div class=&quot;out&quot;&gt; &lt;div class=&quot;in&quot;&gt; 居中元素 &lt;/div&gt; &lt;/div&gt; 水平居中定宽块级元素水平居中 父元素样式设置为display:flex; justify-content:center，则里面包含的块元素居中 .out{ display:flex; justify-content:center; } 该元素样式设置为 margin：0 auto； .in{ width: 100px; margin: 0 auto; } 该元素样式设置为 position: relative;left: 50%；margin-left: -0.5*width（负的该元素宽度的一半） .in{ width: 100px; position: relative; left: 50%; margin-left: -50px; } 上述方法把relative改为absolute也同样适用，根据实际情况选择适合自己的方法。 .in{ width: 100px; position: absolute; left: 50%; margin-left: -50px; } 不定宽块级元素水平居中 对于包含文字的块元素可将其父元素设置为text-align:center .out{ text-align:center; } 若不包含文字，可把该块级元素变成行内元素，即设置display:inine，再给其父元素设置text-align:center .out{ text-align:center; } .in{ display:inine; } 父元素样式设置为display:flex; justify-content:center，则里面包含的块元素居中 .out{ display:flex; justify-content:center; } 该元素样式设置为 position: absolute;left: 50%;transform: translate(-50%,0) .in{ position: absolute; left: 50%; transform: translate(-50%,0); } 垂直居中定高块级元素垂直居中 父元素样式设置为display:flex; align-items: center，则里面包含的块元素居中 .out{ display:flex; align-items: center; } 该元素样式设置为 position: relative;top: 50%；margin-top: -0.5*height（负的该元素高度的一半） .in{ height:100px; position: relative; top: 50%; margin-top:-50px; } 该元素的父元素的position值设置为relative，将该元素样式设置为position: absolute;top:50%;margin-top: -0.5*height .out{ position: relative; } .in{ height:100px; position: absolute; top:50%; margin-top: -50px } 该元素的父元素的position值设置为relative，将该元素样式设置为position: absolute;top:0;bottom: 0;left: 0;right: 0;margin: auto; .out{ position: relative; } .in{ height:100px; position: absolute; top:0; bottom: 0; left: 0; right: 0; margin: auto; } 不定高块级元素垂直居中 父元素样式设置为display:flex; align-items: center，则里面包含的块元素居中 .out{ display:flex; align-items: center; } 该元素样式设置为 position: relative;top: 50%;transform: translate(0,-50%) .in{ position: relative; top: 50%; transform: translate(0,-50%); } 该元素的父元素的position值设置为relative，将该元素样式设置为position: absolute;top:50%;translate(0,-50%) .out{ position: relative; } .in{ position: absolute; top: 50%; transform: translate(0,-50%); } 小结 总结到这里就会发现令元素居中的办法千奇百怪，其中无论水平还是垂直，无论有没有指定宽高，总能奏效的办法就是display:flex办法，这也是flex布局的优势之一，有时候使用flex布局甚至比bootstrap这种框架更加顺手，有机会我也会对flex做个总结。 另外在上面的很多居中的办法中都用到了position: absolute，但是其实不建议经常使用绝对定位进行布局，因为它脱离了文档流，有时会造成元素的塌陷。因为关于position的不同取值带来的效果经常使人困扰，后面我也会对它进行总结。 还有，居中的办法有这么多，但并不代表你需要懂得每一种，甚至去学会一些奇怪或者复杂的居中方式，而是在布局的过程中选择最适合、最简单、你用的最顺手的方法实现你想要的效果，俗话说黑猫白猫，能抓住耗子的就是好猫，居中方式也是一样的道理。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[谈谈我对盒模型的理解]]></title>
      <url>%2F2017%2F03%2F31%2Fcss-box%2F</url>
      <content type="text"><![CDATA[盒子是无处不在的。html任何一个元素都可以看作一个盒子，这个盒子不可见，但是它存在于页面的每个角落，也正是由于它不可见、不直观，很多人在初学CSS的时候不能透彻得理解盒模型的概念，导致在页面布局中出现各种各样的问题。 盒子模型简介 上面是一个盒子模型图，一个盒子包括了content（实际内容）、border（边框）、padding（内边距）和margin（外边距）。 content（实际内容）盒子的内容，显示文本和图像。我们给元素设置的width和height其实是content的宽高， 如果指定高度大于显示内容所需高度，多余的高度会产生类似内边距一样的效果；如果指定高度小于显示内容所需高度，会出现滚动条。如果元素内容的高度大于元素框的高度，浏览器的具体行为取决于overflow属性。 border（边框）元素的边框是围绕元素内容的内边距的一条或多条线。边框由粗细、样式和颜色三部分组成。 padding（内边距）清除内容周围的区域，内边距是透明的，取值不能为负，受盒子的Background属性影响，padding是有背景的。 margin（外边距）在元素外创建额外的空白，空白通常指不能放其他元素的区域，而且在这个区域中可以看到父元素的背景（padding所带的是本身的背景而非父元素）。margin经常取负值实现定位的作用。外边距有一个合并问题，经常使人们混淆，简单来说，外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。 两种盒子模型其实盒模型有两种，分别是ie盒子模型（IE6以下版本浏览器)和标准w3c盒子模型，区别在于前者content的宽度和高度包括了border和padding。margin（外边界）虽不可见，但是它确实在文档中占据了空间，我们要区分两个概念即：盒子所占空间（计入margin ）和盒子实际的大小（不计入margin） 。 实例区分两种盒模型下面举个例子来区分两种盒模型：一个盒子的 margin 为 20px，border 为 2px，padding 为 10px，content 的宽为 200px、高为 50px。 ie盒子模型盒子所占空间：width=20ｘ2+200=240 height=20ｘ2+50=90 盒子实际大小：width=200 height=50 标准w3c盒子模型盒子所占空间：width=20ｘ2+2ｘ2+10ｘ2+200=264 height=20ｘ2+２ｘ2+10ｘ2 +50=114 盒子实际大小：width=200 +2ｘ2+10ｘ2 =224 height=50+2ｘ2+10ｘ2=74 解释到这里，有的人可能会想起CSS3里面有个叫做box-sizing的属性，咦？两个盒模型不就是它不同取值下的效果吗？那我恭喜你，你说对了～ box-sizing和两种盒模型不得不说的事box-sizing有三个取值： 1、content-box:使元素遵循标准 w3c 盒子模型（默认值）。 2、border-box:使元素遵循ie 盒子模型。 3、 inherit： 规定应从父元素继承 box-sizing 属性的值。 那么我可以用box-sizing的不同取值让大家直观地理解两个盒子的区别，也顺带理解这个属性，下面是需要用到的html代码，方便大家看得清楚，我给盒子外面添加一个宽高各500px的灰色背景。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;盒模型&lt;/title&gt; &lt;link href=&quot;盒模型.css&quot; type=&quot;text/css&quot; rel=&quot;stylesheet&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;bg&quot;&gt; &lt;div class=&quot;box&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; box-sizing：content-box.box{ background-color: #91D4DA; width: 300px; height: 300px; padding: 20px; border: 10px solid #5B5B5B; box-sizing: content-box; /*默认值，可以不写*/ } 下面改变padding和border的值 .box{ background-color: #91D4DA; width: 300px; height: 300px; padding: 50px; border: 20px solid #5B5B5B; box-sizing: content-box; /*默认值，可以不写*/ } 大家可以发现，元素盒子的实际宽度是随padding和border改变的。 box-sizing：border-box： .box{ background-color: #91D4DA; width: 300px; height: 300px; padding: 20px; border: 10px solid #5B5B5B; box-sizing: border-box; } 下面改变padding和border的值 .box{ background-color: #91D4DA; width: 300px; height: 300px; padding: 50px; border: 20px solid #5B5B5B; box-sizing: border-box; } 发现区别了吧，当你遵循ie盒子模型时，不管你如何设置padding和border（小于width/2），它只在盒子里面伸缩，不影响整体的宽高，这个border-box是不是在某些时候非常好用？但也不能盲目地用，因为它会影响content，如果padding和border太大，会把内容挤掉的。 现在还在用IE6以下的浏览器的用户已经很少了，所以目前浏览器大部分元素都是基于W3C标准盒子模型 上。所以我们平常说的盒子模型一般就是标准 w3c 盒子模型 （但对于input、button元素默认border-box ，还是基于传统的ie 盒子模型 ）。一定有人会问，那我们怎样让我们的元素都遵循W3C标准盒子模型呢？哈哈，看看你html的文件头部是不是有一个&lt;!DOCTYPE html&gt;，有这个，就说明你已经遵循W3C标准盒子模型了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一个简易弹幕]]></title>
      <url>%2F2017%2F02%2F11%2Fdanmu%2F</url>
      <content type="text"><![CDATA[这是一个用jquery写的弹幕，下面是一点心得。编写jquery的要点在于以下几个方面：1.获取随机高度和随机颜色2.绑定点击和回车事件3.获取输入内容并以动画形式添加到窗口下面贴出完整代码，一些细节都会提到 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;弹幕&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; body{ background-color: gainsboro; } .main{ margin:auto; background-color:rgba(71,71,71,0.95); height: 500px; width: 60%; } .screen{ background-color: antiquewhite; margin: 0; padding: 0; width: 100%; height: 90%; position: relative; overflow: hidden; /*overflow: hidden对screen外的部分进行裁剪，弹幕内容只出现在screen中*/ } .input{ margin-left: 17%; margin-top: 10px; padding-left: 2%; width: 50%; height: 30px; border-radius: 10px 0 0 10px; border: none; } .button{ position: relative; top:-32px; padding: 0; margin-left: 69%; height: 32px; width: 10%; border-radius: 0 10px 10px 0; background-color: rgba(80,188,50,0.95); border: none; color: white; } .button:hover{ background-color: rgba(66,156,42,0.95); cursor: pointer; } #spa{ position: absolute; /*在JS中定义top,right要建立在 position: absolute基础上*/ width: 200px; /*设置弹幕的宽度*/ right: -200px; /*弹幕从screen边界右边200px处开始，与宽度相等，当大于宽度时会延迟到来时间，小于时会从screen内部开始*/ } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;screen&quot;&gt; &lt;/div&gt; &lt;div class=&quot;foot&quot;&gt; &lt;input id=&quot;in&quot; class=&quot;input&quot; type=&quot;text&quot; placeholder=&quot;说点什么...&quot;&gt; &lt;button id=&quot;btn&quot; class=&quot;button&quot; type=&quot;button&quot;&gt;发送&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;script language=&quot;javascript&quot; src=&quot;http://apps.bdimg.com/libs/jquery/2.1.1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script language=&quot;JavaScript&quot;&gt; var screenW=parseInt($(&quot;.screen&quot;).width()); //获取screen窗口的宽度 var screenH=parseInt($(&quot;.screen&quot;).height()); //获取screen窗口的高度 $(&quot;#btn&quot;).bind(&quot;click&quot;,auto); //bind(&quot;e&quot;.function)此处function只能写函数名auto,不能写auto() document.onkeydown=function (e) { //绑定点击和回车 if (e.keyCode == 13){ auto(); //此处需写auto() } } function auto() { var inp = $(&quot;#in&quot;).val(); //val()获取input或hidden或摁键对象的值 $(&quot;#in&quot;).val(&quot;&quot;); //val(&quot;&quot;)给input或hidden或摁键对象赋一个空值,只使用input或hidden对象，起清空作用 var newspan = $(&quot;&lt;span id=&apos;spa&apos;&gt;&lt;/span&gt;&quot;); //此处设置类或ID方便在CSS文件中进行设置 newspan.text(inp); var top = parseInt(screenH*(Math.random())); //获取随机高度 newspan.css({&quot;color&quot;:getRandomColor(),&quot;top&quot;:top}); //设置随机颜色和高度 $(&quot;.screen&quot;).append(newspan); //将输入内容添加到screen newspan.animate({&quot;right&quot;:screenW+200},10000,&quot;linear&quot;,function(){ $(this).remove(); //左移screenW+200px的动画效果，此处200与前面对应，执行完毕后内容移除 }); } function getRandomColor(){ //获取随机颜色 return &apos;#&apos; + (function(h){ return new Array(7 - h.length).join(&quot;0&quot;) + h })((Math.random() * 0x1000000 &lt;&lt; 0).toString(16)); } &lt;/script&gt; &lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[搭建属于自己的博客hexo]]></title>
      <url>%2F2017%2F01%2F15%2Fbuildhexo%2F</url>
      <content type="text"><![CDATA[博客是个好东西啊，很多时候遇到难以解决的技术问题，都是在别人的博客上找到答案的，浏览别人的博客可以学到很多知识。身边认识的大牛都有自己的专属博客，我也想学着折腾一番，也总结了一些经验。 注册GitHub账号 号称全球最大的同性交友网站，作为一个程序员，一个GitHub账号是必须的。 新建仓库 仓库名称格式是username.github.io 注意，此处username要对应你的GitHub用户名 安装node.js 安装nodejs时官方有.msi后缀和.exe后缀两种文件 。其中.msi文件直接下载安装，已经自动配置好环境，.exe文件需要手动配置环境 。若需要安装.exe可以参考我的另一篇博客。官网下载速度略慢，可用淘宝镜像。 安装Git 去官网或者常用的下载软件的网站都可以下载，安装的时候一路next即可。 安装成功之后运行Git Bash 初始化设置$ git config --global user.name “your name” $ git config --global user.email “your email” 注意，此时输入的email必须与注册GitHub账号的邮箱一致 生成密钥$ ssh-keygen -t rsa -C “your email” 按三个回车，密码为空 得到两个文件 id_rsa和id_rsa.pub （这两个文件一般生成在c/user/administrator/ssh文件夹） 添加密钥 打开你的GitHub找到 ssh and gpg key 点击 new ssh key 刚才得到的id_rsa.pub就是要添加的密钥（添加方法：可将id_rsa.pub文件直接拖入浏览器，出现一串字符，将字符copy到需要填写的地方即可） 测试： $ ssh git@github.com 成功后，GitHub上的ssh小钥匙变成绿色 搭建hexo 新建一个文件夹存放你的hexo相关文件（我将它命名为blog） 安装：$ npm install -g hexo 初始化:$ cd blog $ hexo init 如果你cd进入blog之后，执行的是$ hexo init blog,将自动在blog文件夹下生成另一个blog文件，造成混乱 以下命令都在blog中执行 安装插件：$ npm install hexo-generator-index --save #索引生成器 $ npm install hexo-generator-archive --save #归档生成器 $ npm install hexo-generator-category --save #分类生成器 $ npm install hexo-generator-tag --save #标签生成器 $ npm install hexo-server --save #本地服务 $ npm install hexo-deployer-git --save #hexo通过git发布（必装） $ npm install hexo-renderer-marked@0.2.7--save #渲染器 $ npm install hexo-renderer-stylus@0.3.0 --save #渲染器 生成静态页面$ hexo generate #简写 $ hexo g 本地启动$ hexo server #简写 $ hexo s 浏览器输入http://localhost:4000即可看到效果。 发布 找到blog根目录下的_config.yml文件，找到下面的deploy: 并更改为 deploy: type: git repo: https://github.com/Wanghan0/Wanghan0.github.io.git #建好的仓库地址.git branch: master 注意冒号后面有一个字符的空格即英文输入下的一个空格 更改完毕执行下列代码 $ hexo g #生成 $ hexo d #发布 #两行简写 $ hexo d -g 对blog中文件做了更改或者发布文章，都要执行这两行代码才能更新到你的博客好啦现在你可以参观你的博客啦，你的地址就是 https://your_github_username.github.io 写文章编辑器下载Markdown编辑器，windows下推荐MarkdownPad 新建文章在命令行模式下cd至博客的根目录，然后执行以下代码 $ hexo new &quot;postName&quot; 打开刚刚生成的文件 title: postName #文章页面上的显示名称，可以任意修改 date: 2016-02-18 15:30:16 tags: #文章标签，可空，多标签请用格式[tag1,tag2,tag3] categories: #文章分类目录，可空 --- 此处编辑正文 注意冒号后面一个字符的空格 文章摘要如果不想自己的文章在主页全部显示，可在截断处添加 &lt;!--more--&gt; 更多markdown语法 发布文章$ hexo clean $ hexo g $ hexo d 至此，第一篇博文完成 搭建这个博客花了我两天多时间，其实你看这个搭建的步骤并不是很麻烦，而且很多人本来就有github账号，也安装过git,那么搭建起hexo来还不是两行代码的事儿。但是我好菜，我的大部分时间竟然花在安装nodejs上面，最后发现是电脑系统有问题，嗨呀，好气呀，重做系统之后两个小时就装好了。不过如果你是第一次接触hexo总是要摸索一下的，碰到问题也没关系，多百度，多请教别人，只要坚持下来就总会解决的。我这种菜鸡都搭好了，你有什么理由不成功？]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[安装nodejs.exe及其环境配置]]></title>
      <url>%2F2017%2F01%2F14%2F2017-1-14%2F</url>
      <content type="text"><![CDATA[安装nodejs时官方有.msi后缀和.exe后缀两种文件 。其中.msi文件直接下载安装，已经自动配置好环境，.exe文件需要手动配置环境 。然而我在安装.msi文件时出现了进度条回滚的现象，提示 your system has not been modified，关闭杀毒软件，防火墙等保护软件再安装也不起效，尝试很多次都安装失败。于是只能尝试安装.exe文件手动配置,下面就是我的一些安装经验。 任意盘新建一个文件夹，我在D盘新建名为nodejs的文件夹 官网下载.exe文件，存入nodejs文件夹 下载npm文件，解压到nodejs文件夹，得到 node_modules文件与npm.cmd指令文件 配置环境 新建两个变量分别为:NODEJS_PATH与NODEJS_MODULE，NODEJS_PATH指定的是我本地的nodejs目录，NODEJS_MODULE指定的是node_modules目录附 配置方法 重新进nodejs目录，输入 node -v如果输出nodejs的版本则安装成功，npm同理附如何使用cmd进入文件目录 这样就大功告成啦 然而我从cmd验证node,npm都安装成功，git bash上却检测不到npm，环境变量也都设置好了，折腾了一整天都没解决。那天，我坐在电脑前思考人生，我想，我可能是装了假系统。 重做了系统之后直接安装.msi，麻利儿装好，一切都很正常，可见，装一个正版的系统有多么的重要。 我虽然是以这样的方式解决了问题，但是安装nodejs.exe的方法原则上是没错的，如果你的系统没有什么问题的话应该有一些参考价值，但是话又说回来，如果你的系统没有问题，那么从一开始就不会出现进度条回滚的现象，嘻嘻。]]></content>
    </entry>

    
  
  
</search>
